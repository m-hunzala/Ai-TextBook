// src/social-providers/apple.ts
import "arctic";
import { parseJWT } from "oslo/jwt";
import "@better-fetch/fetch";

// src/error/better-auth-error.ts
var BetterAuthError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.name = "BetterAuthError";
    this.message = message;
    this.cause = cause;
    this.stack = "";
  }
};

// src/social-providers/utils.ts
import { OAuth2Tokens } from "arctic";

// src/utils/base-url.ts
function checkHasPath(url) {
  try {
    const parsedUrl = new URL(url);
    return parsedUrl.pathname !== "/";
  } catch (error) {
    throw new BetterAuthError(
      `Invalid base URL: ${url}. Please provide a valid base URL.`
    );
  }
}
function withPath(url, path = "/api/auth") {
  const hasPath = checkHasPath(url);
  if (hasPath) {
    return url;
  }
  path = path.startsWith("/") ? path : `/${path}`;
  return `${url}${path}`;
}
function getBaseURL(url, path) {
  if (url) {
    return withPath(url, path);
  }
  const env = typeof process !== "undefined" ? process.env : {};
  const fromEnv = env.BETTER_AUTH_URL || env.NEXT_PUBLIC_BETTER_AUTH_URL || env.PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_AUTH_URL || (env.BASE_URL !== "/" ? env.BASE_URL : void 0);
  if (fromEnv) {
    return withPath(fromEnv, path);
  }
  if (typeof window !== "undefined") {
    return withPath(window.location.origin, path);
  }
  return void 0;
}

// src/social-providers/utils.ts
import { betterFetch } from "@better-fetch/fetch";
function getRedirectURI(providerId, redirectURI) {
  return redirectURI || `${getBaseURL()}/callback/${providerId}`;
}
async function validateAuthorizationCode({
  code,
  codeVerifier,
  redirectURI,
  options,
  tokenEndpoint
}) {
  const body = new URLSearchParams();
  body.set("grant_type", "authorization_code");
  body.set("code", code);
  codeVerifier && body.set("code_verifier", codeVerifier);
  body.set("redirect_uri", redirectURI);
  body.set("client_id", options.clientId);
  body.set("client_secret", options.clientSecret);
  const { data, error } = await betterFetch(tokenEndpoint, {
    method: "POST",
    body,
    headers: {
      "content-type": "application/x-www-form-urlencoded",
      accept: "application/json",
      "user-agent": "better-auth"
    }
  });
  if (error) {
    throw error;
  }
  const tokens = new OAuth2Tokens(data);
  return tokens;
}

// src/social-providers/apple.ts
var apple = (options) => {
  const tokenEndpoint = "https://appleid.apple.com/auth/token";
  return {
    id: "apple",
    name: "Apple",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scope = scopes || ["email", "name", "openid"];
      return new URL(
        `https://appleid.apple.com/auth/authorize?client_id=${options.clientId}&response_type=code&redirect_uri=${redirectURI || options.redirectURI}&scope=${_scope.join(" ")}&state=${state}`
      );
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: redirectURI || getRedirectURI("apple", options.redirectURI),
        options,
        tokenEndpoint
      });
    },
    async getUserInfo(token) {
      const data = parseJWT(token.idToken())?.payload;
      if (!data) {
        return null;
      }
      return {
        user: {
          id: data.sub,
          name: data.name,
          email: data.email,
          emailVerified: data.email_verified === "true"
        },
        data
      };
    }
  };
};

// src/social-providers/discord.ts
import { betterFetch as betterFetch3 } from "@better-fetch/fetch";
var discord = (options) => {
  return {
    id: "discord",
    name: "Discord",
    createAuthorizationURL({ state, scopes }) {
      const _scopes = scopes || ["identify", "email"];
      return new URL(
        `https://discord.com/api/oauth2/authorize?scope=${_scopes.join(
          "+"
        )}&response_type=code&client_id=${options.clientId}&redirect_uri=${encodeURIComponent(
          getRedirectURI("discord", options.redirectURI)
        )}&state=${state}`
      );
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        redirectURI: redirectURI || getRedirectURI("discord", options.redirectURI),
        options,
        tokenEndpoint: "https://discord.com/api/oauth2/token"
      });
    },
    async getUserInfo(token) {
      const { data: profile, error } = await betterFetch3(
        "https://discord.com/api/users/@me",
        {
          headers: {
            authorization: `Bearer ${token.accessToken()}`
          }
        }
      );
      if (error) {
        return null;
      }
      if (profile.avatar === null) {
        const defaultAvatarNumber = profile.discriminator === "0" ? Number(BigInt(profile.id) >> BigInt(22)) % 6 : parseInt(profile.discriminator) % 5;
        profile.image_url = `https://cdn.discordapp.com/embed/avatars/${defaultAvatarNumber}.png`;
      } else {
        const format = profile.avatar.startsWith("a_") ? "gif" : "png";
        profile.image_url = `https://cdn.discordapp.com/avatars/${profile.id}/${profile.avatar}.${format}`;
      }
      return {
        user: {
          id: profile.id,
          name: profile.display_name || profile.username || "",
          email: profile.email,
          emailVerified: profile.verified,
          image: profile.image_url
        },
        data: profile
      };
    }
  };
};

// src/social-providers/facebook.ts
import { betterFetch as betterFetch4 } from "@better-fetch/fetch";
import { Facebook } from "arctic";
var facebook = (options) => {
  const facebookArctic = new Facebook(
    options.clientId,
    options.clientSecret,
    getRedirectURI("facebook", options.redirectURI)
  );
  return {
    id: "facebook",
    name: "Facebook",
    createAuthorizationURL({ state, scopes }) {
      const _scopes = scopes || ["email", "public_profile"];
      return facebookArctic.createAuthorizationURL(state, _scopes);
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: redirectURI || getRedirectURI("facebook", options.redirectURI),
        options,
        tokenEndpoint: "https://graph.facebook.com/v16.0/oauth/access_token"
      });
    },
    async getUserInfo(token) {
      const { data: profile, error } = await betterFetch4(
        "https://graph.facebook.com/me",
        {
          auth: {
            type: "Bearer",
            token: token.accessToken()
          }
        }
      );
      if (error) {
        return null;
      }
      return {
        user: {
          id: profile.id,
          name: profile.name,
          email: profile.email,
          emailVerified: profile.email_verified
        },
        data: profile
      };
    }
  };
};

// src/social-providers/github.ts
import { betterFetch as betterFetch5 } from "@better-fetch/fetch";
import { GitHub } from "arctic";
var github = ({
  clientId,
  clientSecret,
  redirectURI
}) => {
  const githubArctic = new GitHub(
    clientId,
    clientSecret,
    getRedirectURI("github", redirectURI)
  );
  return {
    id: "github",
    name: "Github",
    createAuthorizationURL({ state, scopes }) {
      const _scopes = scopes || ["user:email"];
      return githubArctic.createAuthorizationURL(state, _scopes);
    },
    validateAuthorizationCode: async (state) => {
      return await githubArctic.validateAuthorizationCode(state);
    },
    async getUserInfo(token) {
      const { data: profile, error } = await betterFetch5(
        "https://api.github.com/user",
        {
          auth: {
            type: "Bearer",
            token: token.accessToken()
          }
        }
      );
      if (error) {
        return null;
      }
      let emailVerified = false;
      if (!profile.email) {
        const { data, error: error2 } = await betterFetch5("https://api.github.com/user/emails", {
          auth: {
            type: "Bearer",
            token: token.accessToken()
          }
        });
        if (!error2) {
          profile.email = (data.find((e) => e.primary) ?? data[0])?.email;
          emailVerified = data.find((e) => e.email === profile.email)?.verified ?? false;
        }
      }
      return {
        user: {
          id: profile.id,
          name: profile.name,
          email: profile.email,
          image: profile.avatar_url,
          emailVerified,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        },
        data: profile
      };
    }
  };
};

// src/social-providers/google.ts
import { Google } from "arctic";
import { parseJWT as parseJWT2 } from "oslo/jwt";

// src/utils/logger.ts
import { createConsola } from "consola";
var consola = createConsola({
  formatOptions: {
    date: false,
    colors: true,
    compact: true
  },
  defaults: {
    tag: "Better Auth"
  }
});
var createLogger = (options) => {
  return {
    log: (...args) => {
      !options?.disabled && consola.log("", ...args);
    },
    error: (...args) => {
      !options?.disabled && consola.error("", ...args);
    },
    warn: (...args) => {
      !options?.disabled && consola.warn("", ...args);
    },
    info: (...args) => {
      !options?.disabled && consola.info("", ...args);
    },
    debug: (...args) => {
      !options?.disabled && consola.debug("", ...args);
    },
    box: (...args) => {
      !options?.disabled && consola.box("", ...args);
    },
    success: (...args) => {
      !options?.disabled && consola.success("", ...args);
    },
    break: (...args) => {
      !options?.disabled && console.log("\n");
    }
  };
};
var logger = createLogger();

// src/social-providers/google.ts
var google = (options) => {
  const googleArctic = new Google(
    options.clientId,
    options.clientSecret,
    getRedirectURI("google", options.redirectURI)
  );
  return {
    id: "google",
    name: "Google",
    createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {
      if (!options.clientId || !options.clientSecret) {
        logger.error(
          "Client Id and Client Secret is required for Google. Make sure to provide them in the options."
        );
        throw new BetterAuthError("CLIENT_ID_AND_SECRET_REQUIRED");
      }
      if (!codeVerifier) {
        throw new BetterAuthError("codeVerifier is required for Google");
      }
      const _scopes = scopes || ["email", "profile"];
      const url = googleArctic.createAuthorizationURL(
        state,
        codeVerifier,
        _scopes
      );
      return url;
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: redirectURI || getRedirectURI("google", options.redirectURI),
        options,
        tokenEndpoint: "https://oauth2.googleapis.com/token"
      });
    },
    async getUserInfo(token) {
      if (!token.idToken) {
        return null;
      }
      const user = parseJWT2(token.idToken())?.payload;
      return {
        user: {
          id: user.sub,
          name: user.name,
          email: user.email,
          image: user.picture,
          emailVerified: user.email_verified
        },
        data: user
      };
    }
  };
};

// src/social-providers/spotify.ts
import { betterFetch as betterFetch6 } from "@better-fetch/fetch";
import { Spotify } from "arctic";
var spotify = (options) => {
  const spotifyArctic = new Spotify(
    options.clientId,
    options.clientSecret,
    getRedirectURI("spotify", options.redirectURI)
  );
  return {
    id: "spotify",
    name: "Spotify",
    createAuthorizationURL({ state, scopes }) {
      const _scopes = scopes || ["user-read-email"];
      return spotifyArctic.createAuthorizationURL(state, _scopes);
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: redirectURI || getRedirectURI("spotify", options.redirectURI),
        options,
        tokenEndpoint: "https://accounts.spotify.com/api/token"
      });
    },
    async getUserInfo(token) {
      const { data: profile, error } = await betterFetch6(
        "https://api.spotify.com/v1/me",
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${token.accessToken()}`
          }
        }
      );
      if (error) {
        return null;
      }
      return {
        user: {
          id: profile.id,
          name: profile.display_name,
          email: profile.email,
          image: profile.images[0]?.url,
          emailVerified: false
        },
        data: profile
      };
    }
  };
};

// src/social-providers/twitch.ts
import { betterFetch as betterFetch7 } from "@better-fetch/fetch";
import { Twitch } from "arctic";
var twitch = (options) => {
  const twitchArctic = new Twitch(
    options.clientId,
    options.clientSecret,
    getRedirectURI("twitch", options.redirectURI)
  );
  return {
    id: "twitch",
    name: "Twitch",
    createAuthorizationURL({ state, scopes }) {
      const _scopes = scopes || ["activity:write", "read"];
      return twitchArctic.createAuthorizationURL(state, _scopes);
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        redirectURI: redirectURI || getRedirectURI("twitch", options.redirectURI),
        options,
        tokenEndpoint: "https://id.twitch.tv/oauth2/token"
      });
    },
    async getUserInfo(token) {
      const { data: profile, error } = await betterFetch7(
        "https://api.twitch.tv/helix/users",
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${token.accessToken()}`
          }
        }
      );
      if (error) {
        return null;
      }
      return {
        user: {
          id: profile.sub,
          name: profile.preferred_username,
          email: profile.email,
          image: profile.picture,
          emailVerified: false
        },
        data: profile
      };
    }
  };
};

// src/social-providers/twitter.ts
import { betterFetch as betterFetch8 } from "@better-fetch/fetch";
import { Twitter } from "arctic";
var twitter = (options) => {
  const twitterArctic = new Twitter(
    options.clientId,
    options.clientSecret,
    getRedirectURI("twitter", options.redirectURI)
  );
  return {
    id: "twitter",
    name: "Twitter",
    createAuthorizationURL(data) {
      const _scopes = data.scopes || ["account_info.read"];
      return twitterArctic.createAuthorizationURL(
        data.state,
        data.codeVerifier,
        _scopes
      );
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: redirectURI || getRedirectURI("twitch", options.redirectURI),
        options,
        tokenEndpoint: "https://id.twitch.tv/oauth2/token"
      });
    },
    async getUserInfo(token) {
      const { data: profile, error } = await betterFetch8(
        "https://api.x.com/2/users/me?user.fields=profile_image_url",
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${token.accessToken()}`
          }
        }
      );
      if (error) {
        return null;
      }
      if (!profile.data.email) {
        return null;
      }
      return {
        user: {
          id: profile.data.id,
          name: profile.data.name,
          email: profile.data.email,
          image: profile.data.profile_image_url,
          emailVerified: profile.data.verified || false
        },
        data: profile
      };
    }
  };
};

// src/types/provider.ts
import "arctic";

// src/social-providers/index.ts
var oAuthProviders = {
  apple,
  discord,
  facebook,
  github,
  google,
  spotify,
  twitch,
  twitter
};
var oAuthProviderList = Object.keys(oAuthProviders);
export {
  apple,
  discord,
  facebook,
  github,
  google,
  oAuthProviderList,
  oAuthProviders,
  spotify,
  twitch,
  twitter
};
