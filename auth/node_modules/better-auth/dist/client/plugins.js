// src/plugins/organization/client.ts
import { atom as atom3 } from "nanostores";

// src/plugins/organization/access/src/access.ts
var ParsingError = class extends Error {
  path;
  constructor(message, path) {
    super(message);
    this.path = path;
  }
};
var AccessControl = class {
  constructor(s) {
    this.s = s;
    this.statements = s;
  }
  statements;
  newRole(statements) {
    return new Role(statements);
  }
};
var Role = class _Role {
  statements;
  constructor(statements) {
    this.statements = statements;
  }
  authorize(request, connector) {
    for (const [requestedResource, requestedActions] of Object.entries(
      request
    )) {
      const allowedActions = this.statements[requestedResource];
      if (!allowedActions) {
        return {
          success: false,
          error: `You are not allowed to access resource: ${requestedResource}`
        };
      }
      const success = connector === "OR" ? requestedActions.some(
        (requestedAction) => allowedActions.includes(requestedAction)
      ) : requestedActions.every(
        (requestedAction) => allowedActions.includes(requestedAction)
      );
      if (success) {
        return { success };
      }
      return {
        success: false,
        error: `unauthorized to access resource "${requestedResource}"`
      };
    }
    return {
      success: false,
      error: "Not authorized"
    };
  }
  static fromString(s) {
    const statements = JSON.parse(s);
    if (typeof statements !== "object") {
      throw new ParsingError("statements is not an object", ".");
    }
    for (const [resource, actions] of Object.entries(statements)) {
      if (typeof resource !== "string") {
        throw new ParsingError("invalid resource identifier", resource);
      }
      if (!Array.isArray(actions)) {
        throw new ParsingError("actions is not an array", resource);
      }
      for (let i = 0; i < actions.length; i++) {
        if (typeof actions[i] !== "string") {
          throw new ParsingError("action is not a string", `${resource}[${i}]`);
        }
      }
    }
    return new _Role(statements);
  }
  toString() {
    return JSON.stringify(this.statements);
  }
};

// src/plugins/organization/access/statement.ts
var createAccessControl = (statements) => {
  return new AccessControl(statements);
};
var defaultStatements = {
  organization: ["update", "delete"],
  member: ["create", "update", "delete"],
  invitation: ["create", "cancel"]
};
var defaultAc = createAccessControl(defaultStatements);
var adminAc = defaultAc.newRole({
  organization: ["update"],
  invitation: ["create", "cancel"],
  member: ["create", "update", "delete"]
});
var ownerAc = defaultAc.newRole({
  organization: ["update", "delete"],
  member: ["create", "update", "delete"],
  invitation: ["create", "cancel"]
});
var memberAc = defaultAc.newRole({
  organization: [],
  member: [],
  invitation: []
});

// src/client/config.ts
import { createFetch } from "@better-fetch/fetch";
import "nanostores";

// src/client/fetch-plugins.ts
import { betterFetch } from "@better-fetch/fetch";

// src/client/session-atom.ts
import { atom as atom2 } from "nanostores";

// src/client/query.ts
import "@better-fetch/fetch";
import { atom, onMount } from "nanostores";
var useAuthQuery = (initializedAtom, path, $fetch, options) => {
  const value = atom({
    data: null,
    error: null,
    isPending: false,
    isRefetching: false
  });
  const fn = () => {
    const opts = typeof options === "function" ? options({
      data: value.get().data,
      error: value.get().error,
      isPending: value.get().isPending
    }) : options;
    return $fetch(path, {
      ...opts,
      onSuccess: async (context) => {
        value.set({
          data: context.data,
          error: null,
          isPending: false,
          isRefetching: false
        });
        await opts?.onSuccess?.(context);
      },
      async onError(context) {
        value.set({
          error: context.error,
          data: null,
          isPending: false,
          isRefetching: false
        });
        await opts?.onError?.(context);
      },
      async onRequest(context) {
        const currentValue = value.get();
        value.set({
          isPending: currentValue.data === null,
          data: currentValue.data,
          error: null,
          isRefetching: true
        });
        await opts?.onRequest?.(context);
      }
    });
  };
  initializedAtom = Array.isArray(initializedAtom) ? initializedAtom : [initializedAtom];
  let isMounted = false;
  for (const initAtom of initializedAtom) {
    initAtom.subscribe(() => {
      if (isMounted) {
        fn();
      } else {
        onMount(value, () => {
          fn();
          isMounted = true;
          return () => {
            value.off();
            initAtom.off();
          };
        });
      }
    });
  }
  return value;
};

// src/plugins/organization/client.ts
var organizationClient = (options) => {
  const activeOrgId = atom3(void 0);
  const _listOrg = atom3(false);
  const _activeOrgSignal = atom3(false);
  return {
    id: "organization",
    $InferServerPlugin: {},
    getActions: ($fetch) => ({
      $Infer: {
        ActiveOrganization: {},
        Organization: {},
        Invitation: {},
        Member: {}
      },
      organization: {
        setActive(orgId) {
          activeOrgId.set(orgId);
        },
        hasPermission: async (data) => {
          return await $fetch("/organization/has-permission", {
            method: "POST",
            body: {
              permission: data.permission
            },
            ...data.fetchOptions
          });
        }
      }
    }),
    getAtoms: ($fetch) => {
      const listOrganizations = useAuthQuery(
        _listOrg,
        "/organization/list",
        $fetch,
        {
          method: "GET"
        }
      );
      const activeOrganization = useAuthQuery(
        [activeOrgId, _activeOrgSignal],
        "/organization/activate",
        $fetch,
        () => ({
          method: "POST",
          credentials: "include",
          body: {
            orgId: activeOrgId.get()
          }
        })
      );
      return {
        _listOrg,
        _activeOrgSignal,
        activeOrganization,
        listOrganizations
      };
    },
    atomListeners: [
      {
        matcher(path) {
          return path === "/organization/create" || path === "/organization/delete";
        },
        signal: "_listOrg"
      },
      {
        matcher(path) {
          return path.startsWith("/organization");
        },
        signal: "_activeOrgSignal"
      }
    ]
  };
};

// src/plugins/username/client.ts
var usernameClient = () => {
  return {
    id: "username",
    $InferServerPlugin: {}
  };
};

// src/plugins/passkey/client.ts
import {
  WebAuthnError,
  startAuthentication,
  startRegistration
} from "@simplewebauthn/browser";
import { atom as atom4 } from "nanostores";
var getPasskeyActions = ($fetch, {
  _listPasskeys
}) => {
  const signInPasskey = async (opts, options) => {
    const response = await $fetch(
      "/passkey/generate-authenticate-options",
      {
        method: "POST",
        body: {
          email: opts?.email,
          callbackURL: opts?.callbackURL
        }
      }
    );
    if (!response.data) {
      return response;
    }
    try {
      const res = await startAuthentication(
        response.data,
        opts?.autoFill || false
      );
      const verified = await $fetch("/passkey/verify-authentication", {
        body: {
          response: res
        },
        ...opts?.fetchOptions,
        ...options
      });
      if (!verified.data) {
        return verified;
      }
    } catch (e) {
      console.log(e);
    }
  };
  const registerPasskey = async (opts, fetchOpts) => {
    const options = await $fetch(
      "/passkey/generate-register-options",
      {
        method: "GET"
      }
    );
    if (!options.data) {
      return options;
    }
    try {
      const res = await startRegistration(options.data);
      const verified = await $fetch("/passkey/verify-registration", {
        ...opts?.fetchOptions,
        ...fetchOpts,
        body: {
          response: res,
          name: opts?.name
        }
      });
      if (!verified.data) {
        return verified;
      }
      _listPasskeys.set(Math.random());
    } catch (e) {
      if (e instanceof WebAuthnError) {
        if (e.code === "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED") {
          return {
            data: null,
            error: {
              message: "previously registered",
              status: 400,
              statusText: "BAD_REQUEST"
            }
          };
        }
        if (e.code === "ERROR_CEREMONY_ABORTED") {
          return {
            data: null,
            error: {
              message: "registration cancelled",
              status: 400,
              statusText: "BAD_REQUEST"
            }
          };
        }
        return {
          data: null,
          error: {
            message: e.message,
            status: 400,
            statusText: "BAD_REQUEST"
          }
        };
      }
      return {
        data: null,
        error: {
          message: e instanceof Error ? e.message : "unknown error",
          status: 500,
          statusText: "INTERNAL_SERVER_ERROR"
        }
      };
    }
  };
  return {
    signIn: {
      /**
       * Sign in with a registered passkey
       */
      passkey: signInPasskey
    },
    passkey: {
      /**
       * Add a passkey to the user account
       */
      addPasskey: registerPasskey
    },
    /**
     * Inferred Internal Types
     */
    $Infer: {}
  };
};
var passkeyClient = () => {
  const _listPasskeys = atom4();
  return {
    id: "passkey",
    $InferServerPlugin: {},
    getActions: ($fetch) => getPasskeyActions($fetch, {
      _listPasskeys
    }),
    getAtoms($fetch) {
      const listPasskeys = useAuthQuery(
        _listPasskeys,
        "/passkey/list-user-passkeys",
        $fetch,
        {
          method: "GET",
          credentials: "include"
        }
      );
      return {
        listPasskeys,
        _listPasskeys
      };
    },
    pathMethods: {
      "/passkey/register": "POST",
      "/passkey/authenticate": "POST"
    },
    atomListeners: [
      {
        matcher(path) {
          return path === "/passkey/verify-registration" || path === "/passkey/delete-passkey";
        },
        signal: "_listPasskeys"
      }
    ]
  };
};

// src/plugins/two-factor/client.ts
var twoFactorClient = (options = {
  redirect: true,
  twoFactorPage: "/"
}) => {
  return {
    id: "two-factor",
    $InferServerPlugin: {},
    atomListeners: [
      {
        matcher: (path) => path === "/two-factor/enable" || path === "/two-factor/send-otp" || path === "/two-factor/disable",
        signal: "_sessionSignal"
      }
    ],
    pathMethods: {
      "/two-factor/disable": "POST",
      "/two-factor/enable": "POST",
      "/two-factor/send-otp": "POST"
    },
    fetchPlugins: [
      {
        id: "two-factor",
        name: "two-factor",
        hooks: {
          async onSuccess(context) {
            if (context.data?.twoFactorRedirect) {
              if (options.redirect || options.twoFactorPage) {
                if (typeof window !== "undefined") {
                  window.location.href = options.twoFactorPage;
                }
              }
            }
          }
        }
      }
    ]
  };
};

// src/plugins/magic-link/client.ts
var magicLinkClient = () => {
  return {
    id: "magic-link",
    $InferServerPlugin: {}
  };
};

// src/plugins/phone-number/client.ts
var phoneNumberClient = () => {
  return {
    id: "phoneNumber",
    $InferServerPlugin: {},
    atomListeners: [
      {
        matcher(path) {
          return path === "/phone-number/update" || path === "/phone-number/verify";
        },
        signal: "_sessionSignal"
      }
    ]
  };
};
export {
  getPasskeyActions,
  magicLinkClient,
  organizationClient,
  passkeyClient,
  phoneNumberClient,
  twoFactorClient,
  usernameClient
};
