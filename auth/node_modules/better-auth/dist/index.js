// src/api/index.ts
import {
  APIError as APIError5,
  createRouter
} from "better-call";

// src/api/middlewares/csrf.ts
import { APIError } from "better-call";
import { z } from "zod";

// src/crypto/index.ts
import { xchacha20poly1305 } from "@noble/ciphers/chacha";
import { bytesToHex, hexToBytes, utf8ToBytes } from "@noble/ciphers/utils";
import { managedNonce } from "@noble/ciphers/webcrypto";
import { sha256 } from "@noble/hashes/sha256";
async function hs256(secretKey, message) {
  const enc = new TextEncoder();
  const algorithm = { name: "HMAC", hash: "SHA-256" };
  const key = await crypto.subtle.importKey(
    "raw",
    enc.encode(secretKey),
    algorithm,
    false,
    ["sign", "verify"]
  );
  const signature = await crypto.subtle.sign(
    algorithm.name,
    key,
    enc.encode(message)
  );
  return btoa(String.fromCharCode(...new Uint8Array(signature)));
}

// src/api/call.ts
import {
  createEndpointCreator,
  createMiddleware,
  createMiddlewareCreator
} from "better-call";
var optionsMiddleware = createMiddleware(async () => {
  return {};
});
var createAuthMiddleware = createMiddlewareCreator({
  use: [
    optionsMiddleware,
    /**
     * Only use for post hooks
     */
    createMiddleware(async () => {
      return {};
    })
  ]
});
var createAuthEndpoint = createEndpointCreator({
  use: [optionsMiddleware]
});

// src/api/middlewares/csrf.ts
var csrfMiddleware = createAuthMiddleware(
  {
    body: z.object({
      csrfToken: z.string().optional()
    }).optional()
  },
  async (ctx) => {
    if (ctx.request?.method !== "POST" || ctx.context.options.advanced?.disableCSRFCheck) {
      return;
    }
    const url = new URL(ctx.request.url);
    if (url.origin === new URL(ctx.context.baseURL).origin || ctx.context.options.trustedOrigins?.includes(url.origin)) {
      return;
    }
    const csrfToken = ctx.body?.csrfToken;
    const csrfCookie = await ctx.getSignedCookie(
      ctx.context.authCookies.csrfToken.name,
      ctx.context.secret
    );
    const [token, hash] = csrfCookie?.split("!") || [null, null];
    if (!csrfToken || !csrfCookie || !token || !hash || csrfCookie !== csrfToken) {
      ctx.setCookie(ctx.context.authCookies.csrfToken.name, "", {
        maxAge: 0
      });
      throw new APIError("UNAUTHORIZED", {
        message: "Invalid CSRF Token"
      });
    }
    const expectedHash = await hs256(ctx.context.secret, token);
    if (hash !== expectedHash) {
      ctx.setCookie(ctx.context.authCookies.csrfToken.name, "", {
        maxAge: 0
      });
      throw new APIError("UNAUTHORIZED", {
        message: "Invalid CSRF Token"
      });
    }
  }
);

// src/api/routes/sign-in.ts
import { APIError as APIError3 } from "better-call";
import { generateCodeVerifier } from "oslo/oauth2";
import { z as z4 } from "zod";

// src/social-providers/apple.ts
import "arctic";
import { parseJWT } from "oslo/jwt";
import "@better-fetch/fetch";

// src/error/better-auth-error.ts
var BetterAuthError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.name = "BetterAuthError";
    this.message = message;
    this.cause = cause;
    this.stack = "";
  }
};

// src/social-providers/utils.ts
import { OAuth2Tokens } from "arctic";

// src/utils/base-url.ts
function checkHasPath(url) {
  try {
    const parsedUrl = new URL(url);
    return parsedUrl.pathname !== "/";
  } catch (error2) {
    throw new BetterAuthError(
      `Invalid base URL: ${url}. Please provide a valid base URL.`
    );
  }
}
function withPath(url, path = "/api/auth") {
  const hasPath = checkHasPath(url);
  if (hasPath) {
    return url;
  }
  path = path.startsWith("/") ? path : `/${path}`;
  return `${url}${path}`;
}
function getBaseURL(url, path) {
  if (url) {
    return withPath(url, path);
  }
  const env = typeof process !== "undefined" ? process.env : {};
  const fromEnv = env.BETTER_AUTH_URL || env.NEXT_PUBLIC_BETTER_AUTH_URL || env.PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_AUTH_URL || (env.BASE_URL !== "/" ? env.BASE_URL : void 0);
  if (fromEnv) {
    return withPath(fromEnv, path);
  }
  if (typeof window !== "undefined") {
    return withPath(window.location.origin, path);
  }
  return void 0;
}

// src/social-providers/utils.ts
import { betterFetch } from "@better-fetch/fetch";
function getRedirectURI(providerId, redirectURI) {
  return redirectURI || `${getBaseURL()}/callback/${providerId}`;
}
async function validateAuthorizationCode({
  code,
  codeVerifier,
  redirectURI,
  options,
  tokenEndpoint
}) {
  const body = new URLSearchParams();
  body.set("grant_type", "authorization_code");
  body.set("code", code);
  codeVerifier && body.set("code_verifier", codeVerifier);
  body.set("redirect_uri", redirectURI);
  body.set("client_id", options.clientId);
  body.set("client_secret", options.clientSecret);
  const { data, error: error2 } = await betterFetch(tokenEndpoint, {
    method: "POST",
    body,
    headers: {
      "content-type": "application/x-www-form-urlencoded",
      accept: "application/json",
      "user-agent": "better-auth"
    }
  });
  if (error2) {
    throw error2;
  }
  const tokens = new OAuth2Tokens(data);
  return tokens;
}

// src/social-providers/apple.ts
var apple = (options) => {
  const tokenEndpoint = "https://appleid.apple.com/auth/token";
  return {
    id: "apple",
    name: "Apple",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scope = scopes || ["email", "name", "openid"];
      return new URL(
        `https://appleid.apple.com/auth/authorize?client_id=${options.clientId}&response_type=code&redirect_uri=${redirectURI || options.redirectURI}&scope=${_scope.join(" ")}&state=${state}`
      );
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: redirectURI || getRedirectURI("apple", options.redirectURI),
        options,
        tokenEndpoint
      });
    },
    async getUserInfo(token) {
      const data = parseJWT(token.idToken())?.payload;
      if (!data) {
        return null;
      }
      return {
        user: {
          id: data.sub,
          name: data.name,
          email: data.email,
          emailVerified: data.email_verified === "true"
        },
        data
      };
    }
  };
};

// src/social-providers/discord.ts
import { betterFetch as betterFetch3 } from "@better-fetch/fetch";
var discord = (options) => {
  return {
    id: "discord",
    name: "Discord",
    createAuthorizationURL({ state, scopes }) {
      const _scopes = scopes || ["identify", "email"];
      return new URL(
        `https://discord.com/api/oauth2/authorize?scope=${_scopes.join(
          "+"
        )}&response_type=code&client_id=${options.clientId}&redirect_uri=${encodeURIComponent(
          getRedirectURI("discord", options.redirectURI)
        )}&state=${state}`
      );
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        redirectURI: redirectURI || getRedirectURI("discord", options.redirectURI),
        options,
        tokenEndpoint: "https://discord.com/api/oauth2/token"
      });
    },
    async getUserInfo(token) {
      const { data: profile, error: error2 } = await betterFetch3(
        "https://discord.com/api/users/@me",
        {
          headers: {
            authorization: `Bearer ${token.accessToken()}`
          }
        }
      );
      if (error2) {
        return null;
      }
      if (profile.avatar === null) {
        const defaultAvatarNumber = profile.discriminator === "0" ? Number(BigInt(profile.id) >> BigInt(22)) % 6 : parseInt(profile.discriminator) % 5;
        profile.image_url = `https://cdn.discordapp.com/embed/avatars/${defaultAvatarNumber}.png`;
      } else {
        const format = profile.avatar.startsWith("a_") ? "gif" : "png";
        profile.image_url = `https://cdn.discordapp.com/avatars/${profile.id}/${profile.avatar}.${format}`;
      }
      return {
        user: {
          id: profile.id,
          name: profile.display_name || profile.username || "",
          email: profile.email,
          emailVerified: profile.verified,
          image: profile.image_url
        },
        data: profile
      };
    }
  };
};

// src/social-providers/facebook.ts
import { betterFetch as betterFetch4 } from "@better-fetch/fetch";
import { Facebook } from "arctic";
var facebook = (options) => {
  const facebookArctic = new Facebook(
    options.clientId,
    options.clientSecret,
    getRedirectURI("facebook", options.redirectURI)
  );
  return {
    id: "facebook",
    name: "Facebook",
    createAuthorizationURL({ state, scopes }) {
      const _scopes = scopes || ["email", "public_profile"];
      return facebookArctic.createAuthorizationURL(state, _scopes);
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: redirectURI || getRedirectURI("facebook", options.redirectURI),
        options,
        tokenEndpoint: "https://graph.facebook.com/v16.0/oauth/access_token"
      });
    },
    async getUserInfo(token) {
      const { data: profile, error: error2 } = await betterFetch4(
        "https://graph.facebook.com/me",
        {
          auth: {
            type: "Bearer",
            token: token.accessToken()
          }
        }
      );
      if (error2) {
        return null;
      }
      return {
        user: {
          id: profile.id,
          name: profile.name,
          email: profile.email,
          emailVerified: profile.email_verified
        },
        data: profile
      };
    }
  };
};

// src/social-providers/github.ts
import { betterFetch as betterFetch5 } from "@better-fetch/fetch";
import { GitHub } from "arctic";
var github = ({
  clientId,
  clientSecret,
  redirectURI
}) => {
  const githubArctic = new GitHub(
    clientId,
    clientSecret,
    getRedirectURI("github", redirectURI)
  );
  return {
    id: "github",
    name: "Github",
    createAuthorizationURL({ state, scopes }) {
      const _scopes = scopes || ["user:email"];
      return githubArctic.createAuthorizationURL(state, _scopes);
    },
    validateAuthorizationCode: async (state) => {
      return await githubArctic.validateAuthorizationCode(state);
    },
    async getUserInfo(token) {
      const { data: profile, error: error2 } = await betterFetch5(
        "https://api.github.com/user",
        {
          auth: {
            type: "Bearer",
            token: token.accessToken()
          }
        }
      );
      if (error2) {
        return null;
      }
      let emailVerified = false;
      if (!profile.email) {
        const { data, error: error3 } = await betterFetch5("https://api.github.com/user/emails", {
          auth: {
            type: "Bearer",
            token: token.accessToken()
          }
        });
        if (!error3) {
          profile.email = (data.find((e) => e.primary) ?? data[0])?.email;
          emailVerified = data.find((e) => e.email === profile.email)?.verified ?? false;
        }
      }
      return {
        user: {
          id: profile.id,
          name: profile.name,
          email: profile.email,
          image: profile.avatar_url,
          emailVerified,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        },
        data: profile
      };
    }
  };
};

// src/social-providers/google.ts
import { Google } from "arctic";
import { parseJWT as parseJWT2 } from "oslo/jwt";

// src/utils/logger.ts
import { createConsola } from "consola";
var consola = createConsola({
  formatOptions: {
    date: false,
    colors: true,
    compact: true
  },
  defaults: {
    tag: "Better Auth"
  }
});
var createLogger = (options) => {
  return {
    log: (...args) => {
      !options?.disabled && consola.log("", ...args);
    },
    error: (...args) => {
      !options?.disabled && consola.error("", ...args);
    },
    warn: (...args) => {
      !options?.disabled && consola.warn("", ...args);
    },
    info: (...args) => {
      !options?.disabled && consola.info("", ...args);
    },
    debug: (...args) => {
      !options?.disabled && consola.debug("", ...args);
    },
    box: (...args) => {
      !options?.disabled && consola.box("", ...args);
    },
    success: (...args) => {
      !options?.disabled && consola.success("", ...args);
    },
    break: (...args) => {
      !options?.disabled && console.log("\n");
    }
  };
};
var logger = createLogger();

// src/social-providers/google.ts
var google = (options) => {
  const googleArctic = new Google(
    options.clientId,
    options.clientSecret,
    getRedirectURI("google", options.redirectURI)
  );
  return {
    id: "google",
    name: "Google",
    createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {
      if (!options.clientId || !options.clientSecret) {
        logger.error(
          "Client Id and Client Secret is required for Google. Make sure to provide them in the options."
        );
        throw new BetterAuthError("CLIENT_ID_AND_SECRET_REQUIRED");
      }
      if (!codeVerifier) {
        throw new BetterAuthError("codeVerifier is required for Google");
      }
      const _scopes = scopes || ["email", "profile"];
      const url = googleArctic.createAuthorizationURL(
        state,
        codeVerifier,
        _scopes
      );
      return url;
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: redirectURI || getRedirectURI("google", options.redirectURI),
        options,
        tokenEndpoint: "https://oauth2.googleapis.com/token"
      });
    },
    async getUserInfo(token) {
      if (!token.idToken) {
        return null;
      }
      const user = parseJWT2(token.idToken())?.payload;
      return {
        user: {
          id: user.sub,
          name: user.name,
          email: user.email,
          image: user.picture,
          emailVerified: user.email_verified
        },
        data: user
      };
    }
  };
};

// src/social-providers/spotify.ts
import { betterFetch as betterFetch6 } from "@better-fetch/fetch";
import { Spotify } from "arctic";
var spotify = (options) => {
  const spotifyArctic = new Spotify(
    options.clientId,
    options.clientSecret,
    getRedirectURI("spotify", options.redirectURI)
  );
  return {
    id: "spotify",
    name: "Spotify",
    createAuthorizationURL({ state, scopes }) {
      const _scopes = scopes || ["user-read-email"];
      return spotifyArctic.createAuthorizationURL(state, _scopes);
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: redirectURI || getRedirectURI("spotify", options.redirectURI),
        options,
        tokenEndpoint: "https://accounts.spotify.com/api/token"
      });
    },
    async getUserInfo(token) {
      const { data: profile, error: error2 } = await betterFetch6(
        "https://api.spotify.com/v1/me",
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${token.accessToken()}`
          }
        }
      );
      if (error2) {
        return null;
      }
      return {
        user: {
          id: profile.id,
          name: profile.display_name,
          email: profile.email,
          image: profile.images[0]?.url,
          emailVerified: false
        },
        data: profile
      };
    }
  };
};

// src/social-providers/twitch.ts
import { betterFetch as betterFetch7 } from "@better-fetch/fetch";
import { Twitch } from "arctic";
var twitch = (options) => {
  const twitchArctic = new Twitch(
    options.clientId,
    options.clientSecret,
    getRedirectURI("twitch", options.redirectURI)
  );
  return {
    id: "twitch",
    name: "Twitch",
    createAuthorizationURL({ state, scopes }) {
      const _scopes = scopes || ["activity:write", "read"];
      return twitchArctic.createAuthorizationURL(state, _scopes);
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        redirectURI: redirectURI || getRedirectURI("twitch", options.redirectURI),
        options,
        tokenEndpoint: "https://id.twitch.tv/oauth2/token"
      });
    },
    async getUserInfo(token) {
      const { data: profile, error: error2 } = await betterFetch7(
        "https://api.twitch.tv/helix/users",
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${token.accessToken()}`
          }
        }
      );
      if (error2) {
        return null;
      }
      return {
        user: {
          id: profile.sub,
          name: profile.preferred_username,
          email: profile.email,
          image: profile.picture,
          emailVerified: false
        },
        data: profile
      };
    }
  };
};

// src/social-providers/twitter.ts
import { betterFetch as betterFetch8 } from "@better-fetch/fetch";
import { Twitter } from "arctic";
var twitter = (options) => {
  const twitterArctic = new Twitter(
    options.clientId,
    options.clientSecret,
    getRedirectURI("twitter", options.redirectURI)
  );
  return {
    id: "twitter",
    name: "Twitter",
    createAuthorizationURL(data) {
      const _scopes = data.scopes || ["account_info.read"];
      return twitterArctic.createAuthorizationURL(
        data.state,
        data.codeVerifier,
        _scopes
      );
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: redirectURI || getRedirectURI("twitch", options.redirectURI),
        options,
        tokenEndpoint: "https://id.twitch.tv/oauth2/token"
      });
    },
    async getUserInfo(token) {
      const { data: profile, error: error2 } = await betterFetch8(
        "https://api.x.com/2/users/me?user.fields=profile_image_url",
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${token.accessToken()}`
          }
        }
      );
      if (error2) {
        return null;
      }
      if (!profile.data.email) {
        return null;
      }
      return {
        user: {
          id: profile.data.id,
          name: profile.data.name,
          email: profile.data.email,
          image: profile.data.profile_image_url,
          emailVerified: profile.data.verified || false
        },
        data: profile
      };
    }
  };
};

// src/types/provider.ts
import "arctic";

// src/social-providers/index.ts
var oAuthProviders = {
  apple,
  discord,
  facebook,
  github,
  google,
  spotify,
  twitch,
  twitter
};
var oAuthProviderList = Object.keys(oAuthProviders);

// src/utils/state.ts
import { generateState as generateStateOAuth } from "oslo/oauth2";
import { z as z2 } from "zod";
function generateState(callbackURL, currentURL, dontRememberMe) {
  const code = generateStateOAuth();
  const state = JSON.stringify({
    code,
    callbackURL,
    currentURL,
    dontRememberMe
  });
  return { state, code };
}
function parseState(state) {
  const data = z2.object({
    code: z2.string(),
    callbackURL: z2.string().optional(),
    currentURL: z2.string().optional(),
    dontRememberMe: z2.boolean().optional()
  }).safeParse(JSON.parse(state));
  return data;
}

// src/api/routes/session.ts
import { APIError as APIError2 } from "better-call";

// src/utils/date.ts
var getDate = (span, unit = "ms") => {
  const date = /* @__PURE__ */ new Date();
  return new Date(date.getTime() + (unit === "sec" ? span * 1e3 : span));
};

// src/utils/cookies.ts
import { TimeSpan } from "oslo";
function getCookies(options) {
  const secure = options.advanced?.useSecureCookies !== void 0 ? options.advanced?.useSecureCookies : options.baseURL?.startsWith("https://") || process.env.NODE_ENV === "production";
  const secureCookiePrefix = secure ? "__Secure-" : "";
  const cookiePrefix = "better-auth";
  const sessionMaxAge = new TimeSpan(7, "d").seconds();
  return {
    sessionToken: {
      name: `${secureCookiePrefix}${cookiePrefix}.session_token`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: !!secureCookiePrefix,
        maxAge: sessionMaxAge
      }
    },
    csrfToken: {
      name: `${secureCookiePrefix ? "__Host-" : ""}${cookiePrefix}.csrf_token`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: !!secureCookiePrefix,
        maxAge: 60 * 60 * 24 * 7
      }
    },
    state: {
      name: `${secureCookiePrefix}${cookiePrefix}.state`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: !!secureCookiePrefix,
        maxAge: 60 * 15
        // 15 minutes in seconds
      }
    },
    pkCodeVerifier: {
      name: `${secureCookiePrefix}${cookiePrefix}.pk_code_verifier`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: !!secureCookiePrefix,
        maxAge: 60 * 15
        // 15 minutes in seconds
      }
    },
    dontRememberToken: {
      name: `${secureCookiePrefix}${cookiePrefix}.dont_remember`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: !!secureCookiePrefix
        //no max age so it expires when the browser closes
      }
    },
    nonce: {
      name: `${secureCookiePrefix}${cookiePrefix}.nonce`,
      options: {
        httpOnly: true,
        sameSite: "lax",
        path: "/",
        secure: !!secureCookiePrefix,
        maxAge: 60 * 15
        // 15 minutes in seconds
      }
    }
  };
}
function createCookieGetter(options) {
  const secure = !!options.advanced?.useSecureCookies || process.env.NODE_ENV === "production";
  const secureCookiePrefix = secure ? "__Secure-" : "";
  const cookiePrefix = "better-auth";
  function getCookie(cookieName, options2) {
    return {
      name: process.env.NODE_ENV === "production" ? `${secureCookiePrefix}${cookiePrefix}.${cookieName}` : `${cookiePrefix}.${cookieName}`,
      options: {
        secure: !!secureCookiePrefix,
        sameSite: "lax",
        path: "/",
        maxAge: 60 * 15,
        // 15 minutes in seconds
        ...options2
      }
    };
  }
  return getCookie;
}
async function setSessionCookie(ctx, sessionToken, dontRememberMe, overrides) {
  const options = ctx.context.authCookies.sessionToken.options;
  options.maxAge = dontRememberMe ? void 0 : options.maxAge;
  await ctx.setSignedCookie(
    ctx.context.authCookies.sessionToken.name,
    sessionToken,
    ctx.context.secret,
    options
  );
  if (dontRememberMe) {
    await ctx.setSignedCookie(
      ctx.context.authCookies.dontRememberToken.name,
      "true",
      ctx.context.secret,
      ctx.context.authCookies.dontRememberToken.options
    );
  }
}
function deleteSessionCookie(ctx) {
  ctx.setCookie(ctx.context.authCookies.sessionToken.name, "", {
    maxAge: 0
  });
  ctx.setCookie(ctx.context.authCookies.dontRememberToken.name, "", {
    maxAge: 0
  });
}

// src/api/routes/session.ts
import { z as z3 } from "zod";

// src/utils/get-request-ip.ts
function getIp(req) {
  const testIP = "127.0.0.1";
  if (process.env.NODE_ENV === "test") {
    return testIP;
  }
  const headers = [
    "x-client-ip",
    "x-forwarded-for",
    "cf-connecting-ip",
    "fastly-client-ip",
    "x-real-ip",
    "x-cluster-client-ip",
    "x-forwarded",
    "forwarded-for",
    "forwarded"
  ];
  for (const header of headers) {
    const value = req.headers.get(header);
    if (typeof value === "string") {
      const ip = value.split(",")[0].trim();
      if (ip) return ip;
    }
  }
  return null;
}

// src/api/routes/session.ts
function getRequestUniqueKey(ctx, token) {
  if (!ctx.request) {
    return "";
  }
  const { method, url, headers } = ctx.request;
  const userAgent = ctx.request.headers.get("User-Agent") || "";
  const ip = getIp(ctx.request) || "";
  const headerString = JSON.stringify(headers);
  const uniqueString = `${method}:${url}:${headerString}:${userAgent}:${ip}:${token}`;
  return uniqueString;
}
var getSession = () => createAuthEndpoint(
  "/session",
  {
    method: "GET",
    requireHeaders: true
  },
  async (ctx) => {
    try {
      const sessionCookieToken = await ctx.getSignedCookie(
        ctx.context.authCookies.sessionToken.name,
        ctx.context.secret
      );
      if (!sessionCookieToken) {
        return ctx.json(null, {
          status: 401
        });
      }
      const key = getRequestUniqueKey(ctx, sessionCookieToken);
      const session = await ctx.context.internalAdapter.findSession(sessionCookieToken);
      if (!session || session.session.expiresAt < /* @__PURE__ */ new Date()) {
        deleteSessionCookie(ctx);
        if (session) {
          await ctx.context.internalAdapter.deleteSession(session.session.id);
        }
        return ctx.json(null, {
          status: 401
        });
      }
      const dontRememberMe = await ctx.getSignedCookie(
        ctx.context.authCookies.dontRememberToken.name,
        ctx.context.secret
      );
      if (dontRememberMe) {
        return ctx.json(
          session
        );
      }
      const expiresIn = ctx.context.sessionConfig.expiresIn;
      const updateAge = ctx.context.sessionConfig.updateAge;
      const sessionIsDueToBeUpdatedDate = session.session.expiresAt.valueOf() - expiresIn * 1e3 + updateAge * 1e3;
      const shouldBeUpdated = sessionIsDueToBeUpdatedDate <= Date.now();
      if (shouldBeUpdated) {
        const updatedSession = await ctx.context.internalAdapter.updateSession(
          session.session.id,
          {
            expiresAt: getDate(ctx.context.sessionConfig.expiresIn, "sec")
          }
        );
        if (!updatedSession) {
          deleteSessionCookie(ctx);
          return ctx.json(null, { status: 401 });
        }
        const maxAge = (updatedSession.expiresAt.valueOf() - Date.now()) / 1e3;
        await setSessionCookie(ctx, updatedSession.id, false, {
          maxAge
        });
        return ctx.json({
          session: updatedSession,
          user: session.user
        });
      }
      return ctx.json(
        session
      );
    } catch (error2) {
      ctx.context.logger.error(error2);
      return ctx.json(null, { status: 500 });
    }
  }
);
var getSessionFromCtx = async (ctx) => {
  const session = await getSession()({
    ...ctx,
    //@ts-expect-error: By default since this request context comes from a router it'll have a `router` flag which force it to be a request object
    _flag: void 0
  });
  return session;
};
var sessionMiddleware = createAuthMiddleware(async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session?.session) {
    throw new APIError2("UNAUTHORIZED");
  }
  return {
    session
  };
});
var listSessions = () => createAuthEndpoint(
  "/user/list-sessions",
  {
    method: "GET",
    use: [sessionMiddleware],
    requireHeaders: true
  },
  async (ctx) => {
    const sessions = await ctx.context.adapter.findMany({
      model: ctx.context.tables.session.tableName,
      where: [
        {
          field: "userId",
          value: ctx.context.session.user.id
        }
      ]
    });
    const activeSessions = sessions.filter((session) => {
      return session.expiresAt > /* @__PURE__ */ new Date();
    });
    return ctx.json(
      activeSessions
    );
  }
);
var revokeSession = createAuthEndpoint(
  "/user/revoke-session",
  {
    method: "POST",
    body: z3.object({
      id: z3.string()
    }),
    use: [sessionMiddleware],
    requireHeaders: true
  },
  async (ctx) => {
    const id = ctx.body.id;
    const findSession = await ctx.context.internalAdapter.findSession(id);
    if (!findSession) {
      return ctx.json(null, { status: 400 });
    }
    if (findSession.session.userId !== ctx.context.session.user.id) {
      return ctx.json(null, { status: 403 });
    }
    try {
      await ctx.context.internalAdapter.deleteSession(id);
    } catch (error2) {
      ctx.context.logger.error(error2);
      return ctx.json(null, { status: 500 });
    }
    return ctx.json({
      status: true
    });
  }
);
var revokeSessions = createAuthEndpoint(
  "/user/revoke-sessions",
  {
    method: "POST",
    use: [sessionMiddleware],
    requireHeaders: true
  },
  async (ctx) => {
    try {
      await ctx.context.internalAdapter.deleteSessions(
        ctx.context.session.user.id
      );
    } catch (error2) {
      ctx.context.logger.error(error2);
      return ctx.json(null, { status: 500 });
    }
    return ctx.json({
      status: true
    });
  }
);

// src/api/routes/sign-in.ts
var signInOAuth = createAuthEndpoint(
  "/sign-in/social",
  {
    method: "POST",
    requireHeaders: true,
    query: z4.object({
      /**
       * Redirect to the current URL after the
       * user has signed in.
       */
      currentURL: z4.string().optional()
    }).optional(),
    body: z4.object({
      /**
       * Callback URL to redirect to after the user has signed in.
       */
      callbackURL: z4.string().optional(),
      /**
       * OAuth2 provider to use`
       */
      provider: z4.enum(oAuthProviderList),
      /**
       * If this is true the session will only be valid for the current browser session
       */
      dontRememberMe: z4.boolean().default(false).optional()
    })
  },
  async (c) => {
    const provider = c.context.socialProviders.find(
      (p) => p.id === c.body.provider
    );
    if (!provider) {
      c.context.logger.error(
        "Provider not found. Make sure to add the provider to your auth config",
        {
          provider: c.body.provider
        }
      );
      throw new APIError3("NOT_FOUND", {
        message: "Provider not found"
      });
    }
    const cookie = c.context.authCookies;
    const currentURL = c.query?.currentURL ? new URL(c.query?.currentURL) : null;
    const callbackURL = c.body.callbackURL?.startsWith("http") ? c.body.callbackURL : `${currentURL?.origin}${c.body.callbackURL || ""}`;
    const state = generateState(
      callbackURL || currentURL?.origin || c.context.baseURL,
      c.query?.currentURL
    );
    try {
      await c.setSignedCookie(
        cookie.state.name,
        state.code,
        c.context.secret,
        cookie.state.options
      );
      const codeVerifier = generateCodeVerifier();
      await c.setSignedCookie(
        cookie.pkCodeVerifier.name,
        codeVerifier,
        c.context.secret,
        cookie.pkCodeVerifier.options
      );
      const url = provider.createAuthorizationURL({
        state: state.state,
        codeVerifier
      });
      url.searchParams.set(
        "redirect_uri",
        `${c.context.baseURL}/callback/${c.body.provider}`
      );
      return {
        url: url.toString(),
        state: state.state,
        codeVerifier,
        redirect: true
      };
    } catch (e) {
      throw new APIError3("INTERNAL_SERVER_ERROR");
    }
  }
);
var signInEmail = createAuthEndpoint(
  "/sign-in/email",
  {
    method: "POST",
    body: z4.object({
      email: z4.string().email(),
      password: z4.string(),
      callbackURL: z4.string().optional(),
      /**
       * If this is true the session will only be valid for the current browser session
       * @default false
       */
      dontRememberMe: z4.boolean().default(false).optional()
    })
  },
  async (ctx) => {
    if (!ctx.context.options?.emailAndPassword?.enabled) {
      ctx.context.logger.error(
        "Email and password is not enabled. Make sure to enable it in the options on you `auth.ts` file. Check `https://better-auth.com/docs/authentication/email-password` for more!"
      );
      throw new APIError3("BAD_REQUEST", {
        message: "Email and password is not enabled"
      });
    }
    const currentSession = await getSessionFromCtx(ctx);
    if (currentSession) {
      await ctx.context.internalAdapter.deleteSession(
        currentSession.session.id
      );
    }
    const { email, password } = ctx.body;
    const checkEmail = z4.string().email().safeParse(email);
    if (!checkEmail.success) {
      throw new APIError3("BAD_REQUEST", {
        message: "Invalid email"
      });
    }
    const user = await ctx.context.internalAdapter.findUserByEmail(email);
    if (!user) {
      await ctx.context.password.hash(password);
      ctx.context.logger.error("User not found", { email });
      throw new APIError3("UNAUTHORIZED", {
        message: "Invalid email or password"
      });
    }
    const credentialAccount = user.accounts.find(
      (a) => a.providerId === "credential"
    );
    if (!credentialAccount) {
      ctx.context.logger.error("Credential account not found", { email });
      throw new APIError3("UNAUTHORIZED", {
        message: "Invalid email or password"
      });
    }
    const currentPassword = credentialAccount?.password;
    if (!currentPassword) {
      ctx.context.logger.error("Password not found", { email });
      throw new APIError3("UNAUTHORIZED", {
        message: "Unexpected error"
      });
    }
    const validPassword = await ctx.context.password.verify(
      currentPassword,
      password
    );
    if (!validPassword) {
      ctx.context.logger.error("Invalid password");
      throw new APIError3("UNAUTHORIZED", {
        message: "Invalid email or password"
      });
    }
    const session = await ctx.context.internalAdapter.createSession(
      user.user.id,
      ctx.headers,
      ctx.body.dontRememberMe
    );
    if (!session) {
      ctx.context.logger.error("Failed to create session");
      throw new APIError3("INTERNAL_SERVER_ERROR");
    }
    await setSessionCookie(ctx, session.id, ctx.body.dontRememberMe);
    return ctx.json({
      user: user.user,
      session,
      redirect: !!ctx.body.callbackURL,
      url: ctx.body.callbackURL
    });
  }
);

// src/api/routes/callback.ts
import { APIError as APIError4 } from "better-call";
import { z as z6 } from "zod";

// src/db/schema.ts
import { z as z5 } from "zod";
var accountSchema = z5.object({
  id: z5.string(),
  providerId: z5.string(),
  accountId: z5.string(),
  userId: z5.string(),
  accessToken: z5.string().nullable().optional(),
  refreshToken: z5.string().nullable().optional(),
  idToken: z5.string().nullable().optional(),
  /**
   * Access token expires at
   */
  expiresAt: z5.date().nullable().optional(),
  /**
   * Password is only stored in the credential provider
   */
  password: z5.string().optional().nullable()
});
var userSchema = z5.object({
  id: z5.string(),
  email: z5.string().transform((val) => val.toLowerCase()),
  emailVerified: z5.boolean().default(false),
  name: z5.string(),
  image: z5.string().optional(),
  createdAt: z5.date().default(/* @__PURE__ */ new Date()),
  updatedAt: z5.date().default(/* @__PURE__ */ new Date())
});
var sessionSchema = z5.object({
  id: z5.string(),
  userId: z5.string(),
  expiresAt: z5.date(),
  ipAddress: z5.string().optional(),
  userAgent: z5.string().optional()
});
var verificationSchema = z5.object({
  id: z5.string(),
  value: z5.string(),
  expiresAt: z5.date(),
  identifier: z5.string()
});

// src/utils/id.ts
import { nanoid } from "nanoid";
var generateId = (size) => {
  return nanoid(size);
};

// src/utils/hide-metadata.ts
var HIDE_METADATA = {
  isAction: false
};

// src/utils/getAccount.ts
function getAccountTokens(tokens) {
  const accessToken = tokens.accessToken();
  let refreshToken = tokens.hasRefreshToken() ? tokens.refreshToken() : void 0;
  let accessTokenExpiresAt = void 0;
  try {
    accessTokenExpiresAt = tokens.accessTokenExpiresAt();
  } catch {
  }
  return {
    accessToken,
    refreshToken,
    expiresAt: accessTokenExpiresAt
  };
}

// src/api/routes/callback.ts
var callbackOAuth = createAuthEndpoint(
  "/callback/:id",
  {
    method: "GET",
    query: z6.object({
      state: z6.string(),
      code: z6.string().optional(),
      error: z6.string().optional()
    }),
    metadata: HIDE_METADATA
  },
  async (c) => {
    if (c.query.error || !c.query.code) {
      const parsedState2 = parseState(c.query.state);
      const callbackURL2 = parsedState2.data?.callbackURL || `${c.context.baseURL}/error`;
      c.context.logger.error(c.query.error, c.params.id);
      throw c.redirect(
        `${callbackURL2}?error=${c.query.error || "oAuth_code_missing"}`
      );
    }
    const provider = c.context.socialProviders.find(
      (p) => p.id === c.params.id
    );
    if (!provider) {
      c.context.logger.error(
        "Oauth provider with id",
        c.params.id,
        "not found"
      );
      throw c.redirect(
        `${c.context.baseURL}/error?error=oauth_provider_not_found`
      );
    }
    const codeVerifier = await c.getSignedCookie(
      c.context.authCookies.pkCodeVerifier.name,
      c.context.secret
    );
    let tokens;
    try {
      tokens = await provider.validateAuthorizationCode(
        c.query.code,
        codeVerifier,
        `${c.context.baseURL}/callback/${provider.id}`
      );
    } catch (e) {
      c.context.logger.error(e);
      throw c.redirect(
        `${c.context.baseURL}/error?error=oauth_code_verification_failed`
      );
    }
    const user = await provider.getUserInfo(tokens).then((res) => res?.user);
    const id = generateId();
    const data = userSchema.safeParse({
      ...user,
      id
    });
    const parsedState = parseState(c.query.state);
    if (!parsedState.success) {
      c.context.logger.error("Unable to parse state");
      throw c.redirect(
        `${c.context.baseURL}/error?error=invalid_state_parameter`
      );
    }
    const { callbackURL, currentURL, dontRememberMe } = parsedState.data;
    if (!user || data.success === false) {
      throw c.redirect(
        `${c.context.baseURL}/error?error=oauth_validation_failed`
      );
    }
    if (!callbackURL) {
      throw c.redirect(
        `${c.context.baseURL}/error?error=oauth_callback_url_not_found`
      );
    }
    const dbUser = await c.context.internalAdapter.findUserByEmail(user.email).catch((e) => {
      logger.error(
        "Better auth was unable to query your database.\nError: ",
        e
      );
      throw c.redirect(
        `${c.context.baseURL}/error?error=internal_server_error`
      );
    });
    const userId = dbUser?.user.id;
    if (dbUser) {
      const hasBeenLinked = dbUser.accounts.find(
        (a) => a.providerId === provider.id
      );
      const trustedProviders = c.context.options.account?.accountLinking?.trustedProviders;
      const isTrustedProvider = trustedProviders ? trustedProviders.includes(provider.id) : true;
      if (!hasBeenLinked && (!user.emailVerified || !isTrustedProvider)) {
        let url;
        try {
          url = new URL(currentURL || callbackURL);
          url.searchParams.set("error", "account_not_linked");
        } catch (e) {
          throw c.redirect(
            `${c.context.baseURL}/error?error=account_not_linked`
          );
        }
        throw c.redirect(url.toString());
      }
      if (!hasBeenLinked) {
        try {
          await c.context.internalAdapter.linkAccount({
            providerId: provider.id,
            accountId: user.id.toString(),
            id: `${provider.id}:${user.id}`,
            userId: dbUser.user.id,
            ...getAccountTokens(tokens)
          });
        } catch (e) {
          console.log(e);
          throw c.redirect(
            `${c.context.baseURL}/error?error=failed_linking_account`
          );
        }
      }
    } else {
      try {
        await c.context.internalAdapter.createOAuthUser(data.data, {
          ...getAccountTokens(tokens),
          id: `${provider.id}:${user.id}`,
          providerId: provider.id,
          accountId: user.id.toString(),
          userId: id
        });
      } catch (e) {
        const url = new URL(currentURL || callbackURL);
        url.searchParams.set("error", "unable_to_create_user");
        c.setHeader("Location", url.toString());
        throw c.redirect(url.toString());
      }
    }
    if (!userId && !id)
      throw new APIError4("INTERNAL_SERVER_ERROR", {
        message: "Unable to create user"
      });
    try {
      const session = await c.context.internalAdapter.createSession(
        userId || id,
        c.request,
        dontRememberMe
      );
      if (!session) {
        const url = new URL(currentURL || callbackURL);
        url.searchParams.set("error", "unable_to_create_session");
        throw c.redirect(url.toString());
      }
      try {
        await setSessionCookie(c, session.id, dontRememberMe);
      } catch (e) {
        c.context.logger.error("Unable to set session cookie", e);
        const url = new URL(currentURL || callbackURL);
        url.searchParams.set("error", "unable_to_create_session");
        throw c.redirect(url.toString());
      }
    } catch {
      const url = new URL(currentURL || callbackURL);
      url.searchParams.set("error", "unable_to_create_session");
      throw c.redirect(url.toString());
    }
    throw c.redirect(callbackURL);
  }
);

// src/api/routes/sign-out.ts
import { z as z7 } from "zod";
var signOut = createAuthEndpoint(
  "/sign-out",
  {
    method: "POST",
    body: z7.optional(
      z7.object({
        callbackURL: z7.string().optional()
      })
    )
  },
  async (ctx) => {
    const sessionCookieToken = await ctx.getSignedCookie(
      ctx.context.authCookies.sessionToken.name,
      ctx.context.secret
    );
    if (!sessionCookieToken) {
      return ctx.json(null);
    }
    await ctx.context.internalAdapter.deleteSession(sessionCookieToken);
    deleteSessionCookie(ctx);
    return ctx.json(null, {
      body: {
        redirect: !!ctx.body?.callbackURL,
        url: ctx.body?.callbackURL
      }
    });
  }
);

// src/api/routes/forget-password.ts
import { TimeSpan as TimeSpan2 } from "oslo";
import { createJWT, parseJWT as parseJWT3 } from "oslo/jwt";
import { validateJWT } from "oslo/jwt";
import { z as z8 } from "zod";
var forgetPassword = createAuthEndpoint(
  "/forget-password",
  {
    method: "POST",
    body: z8.object({
      /**
       * The email address of the user to send a password reset email to.
       */
      email: z8.string().email(),
      /**
       * The URL to redirect the user to reset their password.
       * If the token isn't valid or expired, it'll be redirected with a query parameter `?
       * error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?
       * token=VALID_TOKEN
       */
      redirectTo: z8.string()
    })
  },
  async (ctx) => {
    if (!ctx.context.options.emailAndPassword?.sendResetPassword) {
      ctx.context.logger.error(
        "Reset password isn't enabled.Please pass an emailAndPassword.sendResetPasswordToken function to your auth config!"
      );
      return ctx.json(null, {
        status: 400,
        statusText: "RESET_PASSWORD_EMAIL_NOT_SENT",
        body: {
          message: "Reset password isn't enabled"
        }
      });
    }
    const { email } = ctx.body;
    const user = await ctx.context.internalAdapter.findUserByEmail(email);
    if (!user) {
      return ctx.json(
        {
          status: false
        },
        {
          body: {
            status: true
          }
        }
      );
    }
    const token = await createJWT(
      "HS256",
      Buffer.from(ctx.context.secret),
      {
        email: user.user.email,
        redirectTo: ctx.body.redirectTo
      },
      {
        expiresIn: new TimeSpan2(1, "h"),
        issuer: "better-auth",
        subject: "forget-password",
        audiences: [user.user.email],
        includeIssuedTimestamp: true
      }
    );
    const url = `${ctx.context.baseURL}/reset-password/${token}`;
    await ctx.context.options.emailAndPassword.sendResetPassword(
      url,
      user.user
    );
    return ctx.json({
      status: true
    });
  }
);
var forgetPasswordCallback = createAuthEndpoint(
  "/reset-password/:token",
  {
    method: "GET"
  },
  async (ctx) => {
    const { token } = ctx.params;
    let decodedToken;
    const schema = z8.object({
      email: z8.string(),
      redirectTo: z8.string()
    });
    try {
      decodedToken = await validateJWT(
        "HS256",
        Buffer.from(ctx.context.secret),
        token
      );
      if (!decodedToken.expiresAt || decodedToken.expiresAt < /* @__PURE__ */ new Date()) {
        throw Error("Token expired");
      }
    } catch (e) {
      const decoded = parseJWT3(token);
      const jwt = schema.safeParse(decoded?.payload);
      if (jwt.success) {
        throw ctx.redirect(`${jwt.data?.redirectTo}?error=invalid_token`);
      } else {
        throw ctx.redirect(`${ctx.context.baseURL}/error?error=invalid_token`);
      }
    }
    const { redirectTo } = schema.parse(decodedToken.payload);
    throw ctx.redirect(`${redirectTo}?token=${token}`);
  }
);
var resetPassword = createAuthEndpoint(
  "/reset-password",
  {
    method: "POST",
    query: z8.object({
      currentURL: z8.string()
    }).optional(),
    body: z8.object({
      newPassword: z8.string(),
      callbackURL: z8.string().optional()
    })
  },
  async (ctx) => {
    const token = ctx.query?.currentURL.split("?token=")[1];
    if (!token) {
      return ctx.json(
        {
          error: "Invalid token",
          data: null
        },
        {
          status: 400,
          statusText: "INVALID_TOKEN",
          body: {
            message: "Invalid token"
          }
        }
      );
    }
    const { newPassword } = ctx.body;
    try {
      const jwt = await validateJWT(
        "HS256",
        Buffer.from(ctx.context.secret),
        token
      );
      const email = z8.string().email().parse(jwt.payload.email);
      const user = await ctx.context.internalAdapter.findUserByEmail(email);
      if (!user) {
        return ctx.json(
          {
            error: "User not found",
            data: null
          },
          {
            status: 400,
            body: {
              message: "failed to reset password"
            }
          }
        );
      }
      if (newPassword.length < (ctx.context.options.emailAndPassword?.minPasswordLength || 8) || newPassword.length > (ctx.context.options.emailAndPassword?.maxPasswordLength || 32)) {
        return ctx.json(
          {
            data: null,
            error: "password is too short or too long"
          },
          {
            status: 400,
            statusText: "INVALID_PASSWORD_LENGTH",
            body: {
              message: "password is too short or too long"
            }
          }
        );
      }
      const hashedPassword = await ctx.context.password.hash(newPassword);
      const updatedUser = await ctx.context.internalAdapter.updatePassword(
        user.user.id,
        hashedPassword
      );
      if (!updatedUser) {
        return ctx.json(null, {
          status: 400,
          statusText: "USER_NOT_FOUND",
          body: {
            message: "User doesn't have a credential account"
          }
        });
      }
      return ctx.json(
        {
          error: null,
          data: {
            status: true,
            url: ctx.body.callbackURL,
            redirect: !!ctx.body.callbackURL
          }
        },
        {
          body: {
            status: true,
            url: ctx.body.callbackURL,
            redirect: !!ctx.body.callbackURL
          }
        }
      );
    } catch (e) {
      console.log(e);
      return ctx.json(
        {
          error: "Invalid token",
          data: null
        },
        {
          status: 400,
          statusText: "INVALID_TOKEN",
          body: {
            message: "Invalid token"
          }
        }
      );
    }
  }
);

// src/api/routes/verify-email.ts
import { TimeSpan as TimeSpan3 } from "oslo";
import { createJWT as createJWT2, validateJWT as validateJWT2 } from "oslo/jwt";
import { z as z9 } from "zod";
async function createEmailVerificationToken(secret, email) {
  const token = await createJWT2(
    "HS256",
    Buffer.from(secret),
    {
      email: email.toLowerCase()
    },
    {
      expiresIn: new TimeSpan3(1, "h"),
      issuer: "better-auth",
      subject: "verify-email",
      audiences: [email],
      includeIssuedTimestamp: true
    }
  );
  return token;
}
var sendVerificationEmail = createAuthEndpoint(
  "/send-verification-email",
  {
    method: "POST",
    query: z9.object({
      currentURL: z9.string().optional()
    }).optional(),
    body: z9.object({
      email: z9.string().email(),
      callbackURL: z9.string().optional()
    })
  },
  async (ctx) => {
    if (!ctx.context.options.emailAndPassword?.sendVerificationEmail) {
      ctx.context.logger.error(
        "Verification email isn't enabled. Pass `sendVerificationEmail` in `emailAndPassword` options to enable it."
      );
      return ctx.json(null, {
        status: 400,
        statusText: "VERIFICATION_EMAIL_NOT_SENT",
        body: {
          message: "Verification email isn't enabled"
        }
      });
    }
    const { email } = ctx.body;
    const token = await createEmailVerificationToken(ctx.context.secret, email);
    const url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || ctx.query?.currentURL || "/"}`;
    await ctx.context.options.emailAndPassword.sendVerificationEmail(
      email,
      url,
      token
    );
    return ctx.json({
      status: true
    });
  }
);
var verifyEmail = createAuthEndpoint(
  "/verify-email",
  {
    method: "GET",
    query: z9.object({
      token: z9.string(),
      callbackURL: z9.string().optional()
    })
  },
  async (ctx) => {
    const { token } = ctx.query;
    let jwt;
    try {
      jwt = await validateJWT2("HS256", Buffer.from(ctx.context.secret), token);
    } catch (e) {
      ctx.context.logger.error("Failed to verify email", e);
      return ctx.json(null, {
        status: 400,
        statusText: "INVALID_TOKEN",
        body: {
          message: "Invalid token"
        }
      });
    }
    const schema = z9.object({
      email: z9.string().email()
    });
    const parsed = schema.parse(jwt.payload);
    const user = await ctx.context.internalAdapter.findUserByEmail(
      parsed.email
    );
    if (!user) {
      return ctx.json(null, {
        status: 400,
        statusText: "USER_NOT_FOUND",
        body: {
          message: "User not found"
        }
      });
    }
    const account = user.accounts.find((a) => a.providerId === "credential");
    if (!account) {
      throw ctx.redirect;
    }
    await ctx.context.internalAdapter.updateUserByEmail(parsed.email, {
      emailVerified: true
    });
    if (ctx.query.callbackURL) {
      console.log("Redirecting to", ctx.query.callbackURL);
      throw ctx.redirect("/");
    }
    return ctx.json({
      status: true
    });
  }
);

// src/api/routes/update-user.ts
import { z as z10 } from "zod";

// src/crypto/random.ts
function byteToBinary(byte) {
  return byte.toString(2).padStart(8, "0");
}
function bytesToBinary(bytes) {
  return [...bytes].map((val) => byteToBinary(val)).join("");
}
function bytesToInteger(bytes) {
  return parseInt(bytesToBinary(bytes), 2);
}
function generateRandomInteger(max) {
  if (max < 0 || !Number.isInteger(max)) {
    throw new Error(
      "Argument 'max' must be an integer greater than or equal to 0"
    );
  }
  const bitLength = (max - 1).toString(2).length;
  const shift = bitLength % 8;
  const bytes = new Uint8Array(Math.ceil(bitLength / 8));
  crypto.getRandomValues(bytes);
  if (shift !== 0) {
    bytes[0] &= (1 << shift) - 1;
  }
  let result = bytesToInteger(bytes);
  while (result >= max) {
    crypto.getRandomValues(bytes);
    if (shift !== 0) {
      bytes[0] &= (1 << shift) - 1;
    }
    result = bytesToInteger(bytes);
  }
  return result;
}
function generateRandomString(length, alphabet2) {
  let result = "";
  for (let i = 0; i < length; i++) {
    result += alphabet2[generateRandomInteger(alphabet2.length)];
  }
  return result;
}
function alphabet(...patterns) {
  const patternSet = new Set(patterns);
  let result = "";
  for (const pattern of patternSet) {
    if (pattern === "a-z") {
      result += "abcdefghijklmnopqrstuvwxyz";
    } else if (pattern === "A-Z") {
      result += "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    } else if (pattern === "0-9") {
      result += "0123456789";
    } else {
      result += pattern;
    }
  }
  return result;
}

// src/api/routes/update-user.ts
var updateUser = createAuthEndpoint(
  "/user/update",
  {
    method: "POST",
    body: z10.object({
      name: z10.string().optional(),
      image: z10.string().optional()
    }),
    use: [sessionMiddleware]
  },
  async (ctx) => {
    const { name, image } = ctx.body;
    const session = ctx.context.session;
    if (!image && !name) {
      return ctx.json(session.user);
    }
    const user = await ctx.context.internalAdapter.updateUserByEmail(
      session.user.email,
      {
        name,
        image
      }
    );
    return ctx.json(user);
  }
);
var changePassword = createAuthEndpoint(
  "/user/change-password",
  {
    method: "POST",
    body: z10.object({
      /**
       * The new password to set
       */
      newPassword: z10.string(),
      /**
       * The current password of the user
       */
      currentPassword: z10.string(),
      /**
       * revoke all sessions that are not the
       * current one logged in by the user
       */
      revokeOtherSessions: z10.boolean().optional()
    }),
    use: [sessionMiddleware]
  },
  async (ctx) => {
    const { newPassword, currentPassword, revokeOtherSessions } = ctx.body;
    const session = ctx.context.session;
    const minPasswordLength = ctx.context.password.config.minPasswordLength;
    if (newPassword.length < minPasswordLength) {
      ctx.context.logger.error("Password is too short");
      return ctx.json(null, {
        status: 400,
        body: { message: "Password is too short" }
      });
    }
    const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
    if (newPassword.length > maxPasswordLength) {
      ctx.context.logger.error("Password is too long");
      return ctx.json(null, {
        status: 400,
        body: { message: "Password is too long" }
      });
    }
    const accounts = await ctx.context.internalAdapter.findAccounts(
      session.user.id
    );
    const account = accounts.find(
      (account2) => account2.providerId === "credential" && account2.password
    );
    if (!account || !account.password) {
      return ctx.json(null, {
        status: 400,
        body: { message: "User does not have a password" }
      });
    }
    const passwordHash = await ctx.context.password.hash(newPassword);
    const verify = await ctx.context.password.verify(
      account.password,
      currentPassword
    );
    if (!verify) {
      return ctx.json(null, {
        status: 400,
        body: { message: "Invalid password" }
      });
    }
    await ctx.context.internalAdapter.updateAccount(account.id, {
      password: passwordHash
    });
    if (revokeOtherSessions) {
      await ctx.context.internalAdapter.deleteSessions(session.user.id);
      const newSession = await ctx.context.internalAdapter.createSession(
        session.user.id,
        ctx.headers
      );
      if (!newSession) {
        return ctx.json(null, {
          status: 500,
          body: { message: "Failed to create session" }
        });
      }
      await setSessionCookie(ctx, newSession.id);
    }
    return ctx.json(session.user);
  }
);
var setPassword = createAuthEndpoint(
  "/user/set-password",
  {
    method: "POST",
    body: z10.object({
      /**
       * The new password to set
       */
      newPassword: z10.string()
    }),
    use: [sessionMiddleware]
  },
  async (ctx) => {
    const { newPassword } = ctx.body;
    const session = ctx.context.session;
    const minPasswordLength = ctx.context.password.config.minPasswordLength;
    if (newPassword.length < minPasswordLength) {
      ctx.context.logger.error("Password is too short");
      return ctx.json(null, {
        status: 400,
        body: { message: "Password is too short" }
      });
    }
    const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
    if (newPassword.length > maxPasswordLength) {
      ctx.context.logger.error("Password is too long");
      return ctx.json(null, {
        status: 400,
        body: { message: "Password is too long" }
      });
    }
    const accounts = await ctx.context.internalAdapter.findAccounts(
      session.user.id
    );
    const account = accounts.find(
      (account2) => account2.providerId === "credential" && account2.password
    );
    const passwordHash = await ctx.context.password.hash(newPassword);
    if (!account) {
      await ctx.context.internalAdapter.linkAccount({
        id: generateRandomString(32, alphabet("a-z", "0-9", "A-Z")),
        userId: session.user.id,
        providerId: "credential",
        accountId: session.user.id,
        password: passwordHash
      });
      return ctx.json(session.user);
    }
    return ctx.json(null, {
      status: 400,
      body: { message: "User already has a password" }
    });
  }
);
var deleteUser = createAuthEndpoint(
  "/user/delete",
  {
    method: "POST",
    body: z10.object({
      password: z10.string()
    }),
    use: [sessionMiddleware]
  },
  async (ctx) => {
    const { password } = ctx.body;
    const session = ctx.context.session;
    const accounts = await ctx.context.internalAdapter.findAccounts(
      session.user.id
    );
    const account = accounts.find(
      (account2) => account2.providerId === "credential" && account2.password
    );
    if (!account || !account.password) {
      return ctx.json(null, {
        status: 400,
        body: { message: "User does not have a password" }
      });
    }
    const verify = await ctx.context.password.verify(
      account.password,
      password
    );
    if (!verify) {
      return ctx.json(null, {
        status: 400,
        body: { message: "Invalid password" }
      });
    }
    await ctx.context.internalAdapter.deleteUser(session.user.id);
    await ctx.context.internalAdapter.deleteSessions(session.user.id);
    return ctx.json(null);
  }
);

// src/api/routes/csrf.ts
var getCSRFToken = createAuthEndpoint(
  "/csrf",
  {
    method: "GET",
    metadata: HIDE_METADATA
  },
  async (ctx) => {
    const csrfToken = await ctx.getSignedCookie(
      ctx.context.authCookies.csrfToken.name,
      ctx.context.secret
    );
    if (csrfToken) {
      return {
        csrfToken
      };
    }
    const token = generateRandomString(32, alphabet("a-z", "0-9", "A-Z"));
    const hash = await hs256(ctx.context.secret, token);
    const cookie = `${token}!${hash}`;
    await ctx.setSignedCookie(
      ctx.context.authCookies.csrfToken.name,
      cookie,
      ctx.context.secret,
      ctx.context.authCookies.csrfToken.options
    );
    return {
      csrfToken: token
    };
  }
);

// src/api/routes/error.ts
var html = (errorCode = "Unknown") => `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Authentication Error</title>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --text-color: #212529;
            --accent-color: #000000;
            --error-color: #dc3545;
            --border-color: #e9ecef;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            line-height: 1.5;
        }
        .error-container {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            padding: 2.5rem;
            text-align: center;
            max-width: 90%;
            width: 400px;
        }
        h1 {
            color: var(--error-color);
            font-size: 1.75rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }
        p {
            margin-bottom: 1.5rem;
            color: #495057;
        }
        .btn {
            background-color: var(--accent-color);
            color: #ffffff;
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            transition: all 0.3s ease;
            display: inline-block;
            font-weight: 500;
            border: 2px solid var(--accent-color);
        }
        .btn:hover {
            background-color: #131721;
        }
        .error-code {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }
        .icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="error-container">
        <div class="icon">\u26A0\uFE0F</div>
        <h1>Better Auth Error</h1>
        <p>We encountered an issue while processing your request. Please try again or contact the application owner if the problem persists.</p>
        <a href="/" id="returnLink" class="btn">Return to Application</a>
        <div class="error-code">Error Code: <span id="errorCode">${errorCode}</span></div>
    </div>
</body>
</html>`;
var error = createAuthEndpoint(
  "/error",
  {
    method: "GET",
    metadata: HIDE_METADATA
  },
  async (c) => {
    const query = new URL(c.request?.url || "").searchParams.get("error") || "Unknown";
    return new Response(html(query), {
      headers: {
        "Content-Type": "text/html"
      }
    });
  }
);

// src/api/routes/ok.ts
var ok = createAuthEndpoint(
  "/ok",
  {
    method: "GET",
    metadata: HIDE_METADATA
  },
  async (ctx) => {
    return ctx.json({
      ok: true
    });
  }
);

// src/api/routes/sign-up.ts
import { z as z11 } from "zod";
var signUpEmail = createAuthEndpoint(
  "/sign-up/email",
  {
    method: "POST",
    query: z11.object({
      currentURL: z11.string().optional()
    }).optional(),
    body: z11.object({
      name: z11.string(),
      email: z11.string(),
      password: z11.string(),
      image: z11.string().optional(),
      callbackURL: z11.string().optional()
    })
  },
  async (ctx) => {
    if (!ctx.context.options.emailAndPassword?.enabled) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Email and password is not enabled"
        }
      });
    }
    const { name, email, password, image } = ctx.body;
    const isValidEmail = z11.string().email().safeParse(email);
    if (!isValidEmail.success) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Invalid email address"
        }
      });
    }
    const minPasswordLength = ctx.context.password.config.minPasswordLength;
    if (password.length < minPasswordLength) {
      ctx.context.logger.error("Password is too short");
      return ctx.json(null, {
        status: 400,
        body: { message: "Password is too short" }
      });
    }
    const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
    if (password.length > maxPasswordLength) {
      ctx.context.logger.error("Password is too long");
      return ctx.json(null, {
        status: 400,
        body: { message: "Password is too long" }
      });
    }
    const dbUser = await ctx.context.internalAdapter.findUserByEmail(email);
    const hash = await ctx.context.password.hash(password);
    if (dbUser?.user) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "User already exists"
        }
      });
    }
    const createdUser = await ctx.context.internalAdapter.createUser({
      id: generateRandomString(32, alphabet("a-z", "0-9", "A-Z")),
      email: email.toLowerCase(),
      name,
      image,
      emailVerified: false,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    });
    if (!createdUser) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Could not create user"
        }
      });
    }
    await ctx.context.internalAdapter.linkAccount({
      id: generateRandomString(32, alphabet("a-z", "0-9", "A-Z")),
      userId: createdUser.id,
      providerId: "credential",
      accountId: createdUser.id,
      password: hash
    });
    const session = await ctx.context.internalAdapter.createSession(
      createdUser.id,
      ctx.request
    );
    if (!session) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Could not create session"
        }
      });
    }
    await setSessionCookie(ctx, session.id);
    if (ctx.context.options.emailAndPassword.sendEmailVerificationOnSignUp) {
      const token = await createEmailVerificationToken(
        ctx.context.secret,
        createdUser.email
      );
      const url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || ctx.query?.currentURL || "/"}`;
      await ctx.context.options.emailAndPassword.sendVerificationEmail?.(
        createdUser.email,
        url,
        token
      );
    }
    return ctx.json(
      {
        user: createdUser,
        session
      },
      {
        body: ctx.body.callbackURL ? {
          url: ctx.body.callbackURL,
          redirect: true
        } : {
          user: createdUser,
          session
        }
      }
    );
  }
);

// src/api/index.ts
import chalk from "chalk";

// src/api/rate-limiter.ts
function shouldRateLimit(max, window2, rateLimitData) {
  const now = Date.now();
  const windowInMs = window2 * 1e3;
  const timeSinceLastRequest = now - rateLimitData.lastRequest;
  return timeSinceLastRequest < windowInMs && rateLimitData.count >= max;
}
function rateLimitResponse(retryAfter) {
  return new Response(
    JSON.stringify({
      message: "Too many requests. Please try again later."
    }),
    {
      status: 429,
      statusText: "Too Many Requests",
      headers: {
        "X-Retry-After": retryAfter.toString()
      }
    }
  );
}
function getRetryAfter(lastRequest, window2) {
  const now = Date.now();
  const windowInMs = window2 * 1e3;
  return Math.ceil((lastRequest + windowInMs - now) / 1e3);
}
function createDBStorage(ctx, tableName) {
  const model = tableName ?? "rateLimit";
  const db = ctx.adapter;
  return {
    get: async (key) => {
      const res = await db.findOne({
        model,
        where: [{ field: "key", value: key }]
      });
      return res;
    },
    set: async (key, value, _update) => {
      try {
        if (_update) {
          await db.update({
            model: tableName ?? "rateLimit",
            where: [{ field: "key", value: key }],
            update: {
              count: value.count,
              lastRequest: value.lastRequest
            }
          });
        } else {
          await db.create({
            model: tableName ?? "rateLimit",
            data: {
              key,
              count: value.count,
              lastRequest: value.lastRequest
            }
          });
        }
      } catch (e) {
        logger.error("Error setting rate limit", e);
      }
    }
  };
}
var memory = /* @__PURE__ */ new Map();
function getRateLimitStorage(ctx) {
  if (ctx.rateLimit.customStorage) {
    return ctx.rateLimit.customStorage;
  }
  const storage = ctx.rateLimit.storage;
  if (storage === "memory") {
    return {
      async get(key) {
        return memory.get(key);
      },
      async set(key, value, _update) {
        memory.set(key, value);
      }
    };
  }
  return createDBStorage(ctx, ctx.rateLimit.tableName);
}
async function onRequestRateLimit(req, ctx) {
  if (!ctx.rateLimit.enabled) {
    return;
  }
  const baseURL = ctx.baseURL;
  const path = req.url.replace(baseURL, "");
  let window2 = ctx.rateLimit.window;
  let max = ctx.rateLimit.max;
  const key = getIp(req) + path;
  const specialRules = getDefaultSpecialRules();
  const specialRule = specialRules.find((rule) => rule.pathMatcher(path));
  if (specialRule) {
    window2 = specialRule.window;
    max = specialRule.max;
  }
  for (const plugin of ctx.options.plugins || []) {
    if (plugin.rateLimit) {
      const matchedRule = plugin.rateLimit.find(
        (rule) => rule.pathMatcher(path)
      );
      if (matchedRule) {
        window2 = matchedRule.window;
        max = matchedRule.max;
        break;
      }
    }
  }
  if (ctx.rateLimit.customRules) {
    const customRule = ctx.rateLimit.customRules[path];
    if (customRule) {
      window2 = customRule.window;
      max = customRule.max;
    }
  }
  const storage = getRateLimitStorage(ctx);
  const data = await storage.get(key);
  const now = Date.now();
  if (!data) {
    await storage.set(key, {
      key,
      count: 1,
      lastRequest: now
    });
  } else {
    const timeSinceLastRequest = now - data.lastRequest;
    if (shouldRateLimit(max, window2, data)) {
      const retryAfter = getRetryAfter(data.lastRequest, window2);
      return rateLimitResponse(retryAfter);
    } else if (timeSinceLastRequest > window2 * 1e3) {
      await storage.set(key, {
        ...data,
        count: 1,
        lastRequest: now
      });
    } else {
      await storage.set(key, {
        ...data,
        count: data.count + 1,
        lastRequest: now
      });
    }
  }
}
function getDefaultSpecialRules() {
  const specialRules = [
    {
      pathMatcher(path) {
        return path.startsWith("/sign-in") || path.startsWith("/sign-up");
      },
      window: 10,
      max: 7
    }
  ];
  return specialRules;
}

// src/api/index.ts
function getEndpoints(ctx, options) {
  const pluginEndpoints = options.plugins?.reduce(
    (acc, plugin) => {
      return {
        ...acc,
        ...plugin.endpoints
      };
    },
    {}
  );
  const middlewares = options.plugins?.map(
    (plugin) => plugin.middlewares?.map((m) => {
      const middleware = async (context) => {
        return m.middleware({
          ...context,
          context: {
            ...ctx,
            ...context.context
          }
        });
      };
      middleware.path = m.path;
      middleware.options = m.middleware.options;
      middleware.headers = m.middleware.headers;
      return {
        path: m.path,
        middleware
      };
    })
  ).filter((plugin) => plugin !== void 0).flat() || [];
  const baseEndpoints = {
    signInOAuth,
    callbackOAuth,
    getCSRFToken,
    getSession: getSession(),
    signOut,
    signUpEmail,
    signInEmail,
    forgetPassword,
    resetPassword,
    verifyEmail,
    sendVerificationEmail,
    changePassword,
    setPassword,
    updateUser,
    deleteUser,
    forgetPasswordCallback,
    listSessions: listSessions(),
    revokeSession,
    revokeSessions
  };
  const endpoints = {
    ...baseEndpoints,
    ...pluginEndpoints,
    ok,
    error
  };
  let api = {};
  for (const [key, value] of Object.entries(endpoints)) {
    api[key] = async (context) => {
      const c = await ctx;
      const endpointRes = await value({
        ...context,
        context: {
          ...c,
          ...context.context
        }
      });
      let response = endpointRes;
      for (const plugin of options.plugins || []) {
        if (plugin.hooks?.after) {
          for (const hook of plugin.hooks.after) {
            const match = hook.matcher(context);
            if (match) {
              const obj = Object.assign(context, {
                context: {
                  ...ctx,
                  returned: response
                }
              });
              const hookRes = await hook.handler(obj);
              if (hookRes && "response" in hookRes) {
                response = hookRes.response;
              }
            }
          }
        }
      }
      return response;
    };
    api[key].path = value.path;
    api[key].method = value.method;
    api[key].options = value.options;
    api[key].headers = value.headers;
  }
  return {
    api,
    middlewares
  };
}
var router = (ctx, options) => {
  const { api, middlewares } = getEndpoints(ctx, options);
  const basePath = new URL(ctx.baseURL).pathname;
  return createRouter(api, {
    extraContext: ctx,
    basePath,
    routerMiddleware: [
      {
        path: "/**",
        middleware: csrfMiddleware
      },
      ...middlewares
    ],
    async onRequest(req) {
      for (const plugin of ctx.options.plugins || []) {
        if (plugin.onRequest) {
          const response = await plugin.onRequest(req, ctx);
          if (response) {
            return response;
          }
        }
      }
      return onRequestRateLimit(req, ctx);
    },
    async onResponse(res) {
      for (const plugin of ctx.options.plugins || []) {
        if (plugin.onResponse) {
          const response = await plugin.onResponse(res, ctx);
          if (response) {
            return response.response;
          }
        }
      }
      return res;
    },
    onError(e) {
      const log = options.logger?.verboseLogging ? logger : void 0;
      if (options.logger?.disabled !== true) {
        if (e instanceof APIError5) {
          if (e.status === "INTERNAL_SERVER_ERROR") {
            logger.error(e);
          }
          log?.error(e.message);
        } else {
          if (typeof e === "object" && e !== null && "message" in e) {
            const errorMessage = e.message;
            if (!errorMessage || typeof errorMessage !== "string") {
              log?.error(e);
              return;
            }
            if (errorMessage.includes("no such table")) {
              logger?.error(
                `Please run ${chalk.green(
                  "npx better-auth migrate"
                )} to create the tables. There are missing tables in your SQLite database.`
              );
            } else if (errorMessage.includes("relation") && errorMessage.includes("does not exist")) {
              logger.error(
                `Please run ${chalk.green(
                  "npx better-auth migrate"
                )} to create the tables. There are missing tables in your PostgreSQL database.`
              );
            } else if (errorMessage.includes("Table") && errorMessage.includes("doesn't exist")) {
              logger?.error(
                `Please run ${chalk.green(
                  "npx better-auth migrate"
                )} to create the tables. There are missing tables in your MySQL database.`
              );
            } else {
              log?.error(e);
            }
          } else {
            log?.error(e);
          }
        }
      }
    }
  });
};

// src/db/get-tables.ts
var getAuthTables = (options) => {
  const pluginSchema = options.plugins?.reduce(
    (acc, plugin) => {
      const schema = plugin.schema;
      if (!schema) return acc;
      for (const [key, value] of Object.entries(schema)) {
        acc[key] = {
          fields: {
            ...acc[key]?.fields,
            ...value.fields
          },
          tableName: key
        };
      }
      return acc;
    },
    {}
  );
  const shouldAddRateLimitTable = options.rateLimit?.storage === "database";
  const rateLimitTable = {
    rateLimit: {
      tableName: options.rateLimit?.tableName || "rateLimit",
      fields: {
        key: {
          type: "string"
        },
        count: {
          type: "number"
        },
        lastRequest: {
          type: "number"
        }
      }
    }
  };
  const { user, session, account, ...pluginTables } = pluginSchema || {};
  const accountFields = options.account?.fields;
  const userFields = options.user?.fields;
  return {
    user: {
      tableName: options.user?.modelName || "user",
      fields: {
        [userFields?.name || "name"]: {
          type: "string",
          required: true
        },
        email: {
          type: "string",
          unique: true,
          required: true
        },
        emailVerified: {
          type: "boolean",
          defaultValue: () => false,
          required: true
        },
        image: {
          type: "string",
          required: false
        },
        createdAt: {
          type: "date",
          defaultValue: () => /* @__PURE__ */ new Date(),
          required: true
        },
        updatedAt: {
          type: "date",
          defaultValue: () => /* @__PURE__ */ new Date(),
          required: true
        },
        ...user?.fields
      },
      order: 0
    },
    session: {
      tableName: options.session?.modelName || "session",
      fields: {
        expiresAt: {
          type: "date",
          required: true
        },
        ipAddress: {
          type: "string",
          required: false
        },
        userAgent: {
          type: "string",
          required: false
        },
        userId: {
          type: "string",
          references: {
            model: options.user?.modelName || "user",
            field: "id",
            onDelete: "cascade"
          },
          required: true
        },
        ...session?.fields
      },
      order: 1
    },
    account: {
      tableName: options.account?.modelName || "account",
      fields: {
        [accountFields?.accountId || "accountId"]: {
          type: "string",
          required: true
        },
        providerId: {
          type: "string",
          required: true
        },
        userId: {
          type: "string",
          references: {
            model: options.user?.modelName || "user",
            field: "id",
            onDelete: "cascade"
          },
          required: true
        },
        accessToken: {
          type: "string",
          required: false
        },
        refreshToken: {
          type: "string",
          required: false
        },
        idToken: {
          type: "string",
          required: false
        },
        expiresAt: {
          type: "date",
          required: false
        },
        password: {
          type: "string",
          required: false
        },
        ...account?.fields
      },
      order: 2
    },
    verification: {
      tableName: options.verification?.modelName || "verification",
      fields: {
        identifier: {
          type: "string",
          required: true
        },
        value: {
          type: "string",
          required: true
        },
        expiresAt: {
          type: "date",
          required: true
        }
      }
    },
    ...pluginTables,
    ...shouldAddRateLimitTable ? rateLimitTable : {}
  };
};

// src/adapters/kysely-adapter/dialect.ts
import { Kysely } from "kysely";
import {
  MysqlDialect,
  PostgresDialect,
  SqliteDialect
} from "kysely";
var createKyselyAdapter = async (config2) => {
  const db = config2.database;
  let dialect = void 0;
  let databaseType = "sqlite";
  if ("createDriver" in db) {
    dialect = db;
    if (dialect instanceof SqliteDialect) {
      databaseType = "sqlite";
    }
    if (dialect instanceof MysqlDialect) {
      databaseType = "mysql";
    }
    if (dialect instanceof PostgresDialect) {
      databaseType = "postgres";
    }
  }
  if ("aggregate" in db) {
    dialect = new SqliteDialect({
      database: db
    });
    databaseType = "sqlite";
  }
  if ("getConnection" in db) {
    dialect = new MysqlDialect({
      pool: db
    });
    databaseType = "mysql";
  }
  if ("connect" in db) {
    dialect = new PostgresDialect({
      pool: db
    });
    databaseType = "postgres";
  }
  return {
    kysely: dialect ? new Kysely({ dialect }) : null,
    dialect,
    databaseType
  };
};

// src/cli/utils/get-migration.ts
import "kysely";

// src/cli/utils/get-schema.ts
function getSchema(config2) {
  const tables = getAuthTables(config2);
  let schema = {};
  for (const key in tables) {
    const table = tables[key];
    if (schema[table.tableName]) {
      schema[table.tableName].fields = {
        ...schema[table.tableName].fields,
        ...table.fields
      };
      continue;
    }
    schema[table.tableName] = {
      fields: table.fields,
      order: table.order || Infinity
    };
  }
  return schema;
}

// src/cli/utils/get-migration.ts
var postgresMap = {
  string: ["character varying", "text"],
  number: [
    "int4",
    "integer",
    "bigint",
    "smallint",
    "numeric",
    "real",
    "double precision"
  ],
  boolean: ["bool", "boolean"],
  date: ["timestamp", "date"]
};
var mysqlMap = {
  string: ["varchar", "text"],
  number: [
    "integer",
    "int",
    "bigint",
    "smallint",
    "decimal",
    "float",
    "double"
  ],
  boolean: ["boolean"],
  date: ["date", "datetime"]
};
var sqliteMap = {
  string: ["TEXT"],
  number: ["INTEGER", "REAL"],
  boolean: ["INTEGER", "BOOLEAN"],
  // 0 or 1
  date: ["DATE", "INTEGER"]
};
var map = {
  postgres: postgresMap,
  mysql: mysqlMap,
  sqlite: sqliteMap
};
function matchType(columnDataType, fieldType, dbType) {
  const types = map[dbType];
  const type = types[fieldType].map((t) => t.toLowerCase());
  const matches = type.includes(columnDataType.toLowerCase());
  return matches;
}
async function getMigrations(config2) {
  const betterAuthSchema = getSchema(config2);
  const { kysely: db, databaseType: dbType } = await createKyselyAdapter(config2);
  if (!db || !dbType) {
    logger.error(
      "Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter."
    );
    process.exit(1);
  }
  const tableMetadata = await db.introspection.getTables();
  const toBeCreated = [];
  const toBeAdded = [];
  for (const [key, value] of Object.entries(betterAuthSchema)) {
    const table = tableMetadata.find((t) => t.name === key);
    if (!table) {
      const tIndex = toBeCreated.findIndex((t) => t.table === key);
      const tableData = {
        table: key,
        fields: value.fields,
        order: value.order || Infinity
      };
      const insertIndex = toBeCreated.findIndex(
        (t) => (t.order || Infinity) > tableData.order
      );
      if (insertIndex === -1) {
        if (tIndex === -1) {
          toBeCreated.push(tableData);
        } else {
          toBeCreated[tIndex].fields = {
            ...toBeCreated[tIndex].fields,
            ...value.fields
          };
        }
      } else {
        toBeCreated.splice(insertIndex, 0, tableData);
      }
      continue;
    }
    let toBeAddedFields = {};
    for (const [fieldName, field] of Object.entries(value.fields)) {
      const column = table.columns.find((c) => c.name === fieldName);
      if (!column) {
        toBeAddedFields[fieldName] = field;
        continue;
      }
      if (matchType(column.dataType, field.type, dbType)) {
        continue;
      } else {
        logger.warn(
          `Field ${fieldName} in table ${key} has a different type in the database. Expected ${field.type} but got ${column.dataType}.`
        );
      }
    }
    if (Object.keys(toBeAddedFields).length > 0) {
      toBeAdded.push({
        table: key,
        fields: toBeAddedFields,
        order: value.order || Infinity
      });
    }
  }
  const migrations = [];
  function getType(type) {
    const typeMap = {
      string: "text",
      boolean: "boolean",
      number: "integer",
      date: "date"
    };
    if (dbType === "mysql" && type === "string") {
      return "varchar(255)";
    }
    return typeMap[type];
  }
  if (toBeAdded.length) {
    for (const table of toBeAdded) {
      for (const [fieldName, field] of Object.entries(table.fields)) {
        const type = getType(field.type);
        const exec = db.schema.alterTable(table.table).addColumn(fieldName, type, (col) => {
          col = field.required !== false ? col.notNull() : col;
          if (field.references) {
            col = col.references(
              `${field.references.model}.${field.references.field}`
            );
          }
          return col;
        });
        migrations.push(exec);
      }
    }
  }
  if (toBeCreated.length) {
    for (const table of toBeCreated) {
      let dbT = db.schema.createTable(table.table).addColumn("id", getType("string"), (col) => col.primaryKey());
      for (const [fieldName, field] of Object.entries(table.fields)) {
        const type = getType(field.type);
        dbT = dbT.addColumn(fieldName, type, (col) => {
          col = field.required !== false ? col.notNull() : col;
          if (field.references) {
            col = col.references(
              `${field.references.model}.${field.references.field}`
            );
          }
          if (field.unique) {
            col = col.unique();
          }
          return col;
        });
      }
      migrations.push(dbT);
    }
  }
  async function runMigrations() {
    for (const migration of migrations) {
      await migration.execute();
    }
  }
  async function compileMigrations() {
    const compiled = migrations.map((m) => m.compile().sql);
    return compiled.join(";\n\n");
  }
  return { toBeCreated, toBeAdded, runMigrations, compileMigrations };
}

// src/adapters/kysely-adapter/index.ts
function convertWhere(w) {
  if (!w)
    return {
      and: null,
      or: null
    };
  const and = w?.filter((w2) => w2.connector === "AND" || !w2.connector).reduce(
    (acc, w2) => ({
      ...acc,
      [w2.field]: w2.value
    }),
    {}
  );
  const or = w?.filter((w2) => w2.connector === "OR").reduce(
    (acc, w2) => ({
      ...acc,
      [w2.field]: w2.value
    }),
    {}
  );
  return {
    and: Object.keys(and).length ? and : null,
    or: Object.keys(or).length ? or : null
  };
}
function transformTo(val, fields, transform) {
  for (const key in val) {
    if (val[key] === 0 && fields[key]?.type === "boolean" && transform?.boolean) {
      val[key] = false;
    }
    if (val[key] === 1 && fields[key]?.type === "boolean" && transform?.boolean) {
      val[key] = true;
    }
    if (fields[key]?.type === "date") {
      if (!(val[key] instanceof Date)) {
        val[key] = new Date(val[key]);
      }
    }
  }
  return val;
}
function transformFrom(val, transform) {
  for (const key in val) {
    if (typeof val[key] === "boolean" && transform?.boolean) {
      val[key] = val[key] ? 1 : 0;
    }
    if (val[key] instanceof Date) {
      val[key] = val[key].toISOString();
    }
  }
  return val;
}
var kyselyAdapter = (db, config2) => {
  return {
    id: "kysely",
    async create(data) {
      let { model, data: val, select } = data;
      if (config2?.transform) {
        val = transformFrom(val, config2.transform);
      }
      let res = await db.insertInto(model).values(val).returningAll().executeTakeFirst();
      if (config2?.transform) {
        const schema = config2.transform.schema[model];
        res = schema ? transformTo(val, schema, config2.transform) : res;
      }
      if (select?.length) {
        const data2 = res ? select.reduce((acc, cur) => {
          if (res?.[cur]) {
            return {
              ...acc,
              [cur]: res[cur]
            };
          }
          return acc;
        }, {}) : null;
        res = data2;
      }
      return res;
    },
    async findOne(data) {
      const { model, where, select } = data;
      const { and, or } = convertWhere(where);
      let query = db.selectFrom(model).selectAll();
      if (or) {
        query = query.where((eb) => eb.or(or));
      }
      if (and) {
        query = query.where((eb) => eb.and(and));
      }
      let res = await query.executeTakeFirst();
      if (select?.length) {
        const data2 = res ? select.reduce((acc, cur) => {
          if (res?.[cur]) {
            return {
              ...acc,
              [cur]: res[cur]
            };
          }
          return acc;
        }, {}) : null;
        res = data2;
      }
      if (config2?.transform) {
        const schema = config2.transform.schema[model];
        res = res && schema ? transformTo(res, schema, config2.transform) : res;
        return res || null;
      }
      return res || null;
    },
    async findMany(data) {
      const { model, where } = data;
      let query = db.selectFrom(model);
      const { and, or } = convertWhere(where);
      if (and) {
        query = query.where((eb) => eb.and(and));
      }
      if (or) {
        query = query.where((eb) => eb.or(or));
      }
      const res = await query.selectAll().execute();
      if (config2?.transform) {
        const schema = config2.transform.schema[model];
        return schema ? res.map((v) => transformTo(v, schema, config2.transform)) : res;
      }
      return res;
    },
    async update(data) {
      let { model, where, update: val } = data;
      const { and, or } = convertWhere(where);
      if (config2?.transform) {
        val = transformFrom(val, config2.transform);
      }
      let query = db.updateTable(model).set(val);
      if (and) {
        query = query.where((eb) => eb.and(and));
      }
      if (or) {
        query = query.where((eb) => eb.or(or));
      }
      const res = await query.returningAll().executeTakeFirst() || null;
      if (config2?.transform) {
        const schema = config2.transform.schema[model];
        return schema ? transformTo(res, schema, config2.transform) : res;
      }
      return res;
    },
    async delete(data) {
      const { model, where } = data;
      const { and, or } = convertWhere(where);
      let query = db.deleteFrom(model);
      if (and) {
        query = query.where((eb) => eb.and(and));
      }
      if (or) {
        query = query.where((eb) => eb.or(or));
      }
      await query.execute();
    },
    async createSchema(options) {
      const { compileMigrations } = await getMigrations(options);
      const migrations = await compileMigrations();
      return {
        code: migrations,
        fileName: `./better-auth_migrations/${(/* @__PURE__ */ new Date()).toISOString()}.sql`
      };
    }
  };
};

// src/db/utils.ts
async function getAdapter(options, isCli) {
  if (!options.database) {
    throw new BetterAuthError("Database configuration is required");
  }
  if ("create" in options.database) {
    return options.database;
  }
  const { kysely, databaseType } = await createKyselyAdapter(options);
  if (!kysely) {
    throw new BetterAuthError("Failed to initialize database adapter");
  }
  const tables = getAuthTables(options);
  let schema = {};
  for (const table of Object.values(tables)) {
    schema[table.tableName] = table.fields;
  }
  return kyselyAdapter(kysely, {
    transform: {
      schema,
      date: true,
      boolean: databaseType === "sqlite"
    }
  });
}

// src/crypto/password.ts
import { scrypt } from "node:crypto";
import { decodeHex, encodeHex } from "oslo/encoding";

// src/crypto/buffer.ts
function constantTimeEqual(a, b) {
  const aBuffer = new Uint8Array(a);
  const bBuffer = new Uint8Array(b);
  if (aBuffer.length !== bBuffer.length) {
    return false;
  }
  let c = 0;
  for (let i = 0; i < aBuffer.length; i++) {
    c |= aBuffer[i] ^ bBuffer[i];
  }
  return c === 0;
}

// src/crypto/password.ts
var config = {
  N: 16384,
  r: 16,
  p: 1,
  dkLen: 64
};
async function generateKey(password, salt) {
  return await new Promise((resolve, reject) => {
    scrypt(
      password.normalize("NFKC"),
      salt,
      config.dkLen,
      {
        N: config.N,
        p: config.p,
        r: config.r,
        // errors when 128 * N * r > `maxmem` (approximately)
        maxmem: 128 * config.N * config.r * 2
      },
      (err, buff) => {
        if (err) return reject(err);
        return resolve(buff);
      }
    );
  });
}
var hashPassword = async (password) => {
  const salt = encodeHex(crypto.getRandomValues(new Uint8Array(16)));
  const key = await generateKey(password, salt);
  return `${salt}:${encodeHex(key)}`;
};
var verifyPassword = async (hash, password) => {
  const [salt, key] = hash.split(":");
  const targetKey = await generateKey(password, salt);
  return constantTimeEqual(targetKey, decodeHex(key));
};

// src/db/with-hooks.ts
function getWithHooks(adapter, ctx) {
  const hooks = ctx.hooks;
  const tables = getAuthTables(ctx.options);
  async function createWithHooks(data, model) {
    let actualData = data;
    for (const hook of hooks || []) {
      const toRun = hook[model]?.create?.before;
      if (toRun) {
        const result = await toRun(data);
        if (result === false) {
          return null;
        }
        const isObject = typeof result === "object";
        actualData = isObject ? result.data : result;
      }
    }
    const created = await adapter.create({
      model: tables[model].tableName,
      data: {
        id: generateId(),
        ...actualData
      }
    });
    for (const hook of hooks || []) {
      const toRun = hook[model]?.create?.after;
      if (toRun) {
        await toRun(created);
      }
    }
    return created;
  }
  async function updateWithHooks(data, where, model) {
    let actualData = data;
    for (const hook of hooks || []) {
      const toRun = hook[model]?.update?.before;
      if (toRun) {
        const result = await toRun(data);
        if (result === false) {
          return null;
        }
        const isObject = typeof result === "object";
        actualData = isObject ? result.data : result;
      }
    }
    const updated = await adapter.update({
      model: tables[model].tableName,
      update: actualData,
      where
    });
    for (const hook of hooks || []) {
      const toRun = hook[model]?.update?.after;
      if (toRun) {
        await toRun(updated);
      }
    }
    return updated;
  }
  return {
    createWithHooks,
    updateWithHooks
  };
}

// src/db/internal-adapter.ts
var createInternalAdapter = (adapter, ctx) => {
  const options = ctx.options;
  const sessionExpiration = options.session?.expiresIn || 60 * 60 * 24 * 7;
  const tables = getAuthTables(options);
  const { createWithHooks, updateWithHooks } = getWithHooks(adapter, ctx);
  return {
    createOAuthUser: async (user, account) => {
      try {
        const createdUser = await createWithHooks(user, "user");
        const createdAccount = await createWithHooks(account, "account");
        return {
          user: createdUser,
          account: createdAccount
        };
      } catch (e) {
        console.log(e);
        return null;
      }
    },
    createUser: async (user) => {
      const createdUser = await createWithHooks(user, "user");
      return createdUser;
    },
    deleteUser: async (userId) => {
      await adapter.delete({
        model: tables.user.tableName,
        where: [
          {
            field: "id",
            value: userId
          }
        ]
      });
    },
    createSession: async (userId, request, dontRememberMe) => {
      const headers = request instanceof Request ? request.headers : request;
      const data = {
        id: generateId(),
        userId,
        /**
         * If the user doesn't want to be remembered
         * set the session to expire in 1 day.
         * The cookie will be set to expire at the end of the session
         */
        expiresAt: dontRememberMe ? getDate(1e3 * 60 * 60 * 24) : getDate(sessionExpiration, "sec"),
        ipAddress: headers?.get("x-forwarded-for") || "",
        userAgent: headers?.get("user-agent") || ""
      };
      const session = await createWithHooks(data, "session");
      return session;
    },
    findSession: async (sessionId) => {
      const session = await adapter.findOne({
        model: tables.session.tableName,
        where: [
          {
            value: sessionId,
            field: "id"
          }
        ]
      });
      if (!session) {
        return null;
      }
      const user = await adapter.findOne({
        model: tables.user.tableName,
        where: [
          {
            value: session.userId,
            field: "id"
          }
        ]
      });
      if (!user) {
        return null;
      }
      return {
        session,
        user
      };
    },
    updateSession: async (sessionId, session) => {
      const updatedSession = await updateWithHooks(
        session,
        [{ field: "id", value: sessionId }],
        "session"
      );
      return updatedSession;
    },
    deleteSession: async (id) => {
      const session = await adapter.delete({
        model: tables.session.tableName,
        where: [
          {
            field: "id",
            value: id
          }
        ]
      });
    },
    deleteSessions: async (userId) => {
      return await adapter.delete({
        model: tables.session.tableName,
        where: [
          {
            field: "userId",
            value: userId
          }
        ]
      });
    },
    findUserByEmail: async (email) => {
      const user = await adapter.findOne({
        model: tables.user.tableName,
        where: [
          {
            value: email.toLowerCase(),
            field: "email"
          }
        ]
      });
      if (!user) return null;
      const accounts = await adapter.findMany({
        model: tables.account.tableName,
        where: [
          {
            value: user.id,
            field: "userId"
          }
        ]
      });
      return {
        user,
        accounts
      };
    },
    findUserById: async (userId) => {
      const user = await adapter.findOne({
        model: tables.user.tableName,
        where: [
          {
            field: "id",
            value: userId
          }
        ]
      });
      return user;
    },
    linkAccount: async (account) => {
      const _account = await createWithHooks(account, "account");
      return _account;
    },
    updateUser: async (userId, data) => {
      const user = await updateWithHooks(
        data,
        [
          {
            field: "id",
            value: userId
          }
        ],
        "user"
      );
      return user;
    },
    updateUserByEmail: async (email, data) => {
      const user = await updateWithHooks(
        data,
        [{ field: "email", value: email }],
        "user"
      );
      return user;
    },
    updatePassword: async (userId, password) => {
      const account = await updateWithHooks(
        {
          password
        },
        [
          {
            field: "userId",
            value: userId
          },
          {
            field: "providerId",
            value: "credential"
          }
        ],
        "account"
      );
      return account;
    },
    findAccounts: async (userId) => {
      const accounts = await adapter.findMany({
        model: tables.account.tableName,
        where: [
          {
            field: "userId",
            value: userId
          }
        ]
      });
      return accounts;
    },
    updateAccount: async (accountId, data) => {
      const account = await updateWithHooks(
        data,
        [{ field: "id", value: accountId }],
        "account"
      );
      return account;
    },
    createVerificationValue: async (data) => {
      const verification = await createWithHooks(
        {
          id: generateId(),
          ...data
        },
        "verification"
      );
      return verification;
    },
    findVerificationValue: async (identifier) => {
      const verification = await adapter.findOne({
        model: tables.verification.tableName,
        where: [
          {
            field: "identifier",
            value: identifier
          }
        ]
      });
      return verification;
    },
    deleteVerificationValue: async (id) => {
      await adapter.delete({
        model: tables.verification.tableName,
        where: [
          {
            field: "id",
            value: id
          }
        ]
      });
    },
    updateVerificationValue: async (id, data) => {
      const verification = await updateWithHooks(
        data,
        [{ field: "id", value: id }],
        "verification"
      );
      return verification;
    }
  };
};

// src/init.ts
import { defu } from "defu";

// src/utils/constants.ts
var DEFAULT_SECRET = "better-auth-secret-123456789";

// src/internal-plugins/cross-subdomain/index.ts
var crossSubdomainCookies = (options) => {
  return {
    id: "cross-subdomain-cookies",
    async onResponse(response, ctx) {
      const setCookie = response.headers.get("set-cookie");
      if (!setCookie) return;
      const baseURL = ctx.baseURL;
      const cookieParts = setCookie.split(";");
      const domain = options?.domainName || new URL(baseURL).hostname;
      const authCookies = ctx.authCookies;
      const cookieNamesEligibleForDomain = [
        authCookies.sessionToken.name,
        authCookies.csrfToken.name,
        authCookies.dontRememberToken.name
      ];
      if (!cookieNamesEligibleForDomain.some((name) => setCookie.includes(name))) {
        return;
      }
      const updatedCookies = cookieParts.map((part) => {
        if (!cookieNamesEligibleForDomain.some(
          (name) => part.toLowerCase().includes(name.toLowerCase())
        )) {
          return part;
        }
        const trimmedPart = part.trim();
        if (trimmedPart.toLowerCase().startsWith("domain=")) {
          return `Domain=${domain}`;
        }
        if (!trimmedPart.toLowerCase().includes("domain=")) {
          return `${trimmedPart}; Domain=${domain}`;
        }
        return trimmedPart;
      }).filter(
        (part, index, self) => index === self.findIndex((p) => p.split(";")[0] === part.split(";")[0])
      ).join("; ");
      response.headers.set("set-cookie", updatedCookies);
      return {
        response
      };
    }
  };
};

// src/init.ts
var init = async (opts) => {
  let { options, context, dbHooks } = runPluginInit(opts);
  const plugins = options.plugins || [];
  const internalPlugins = getInternalPlugins(options);
  const adapter = await getAdapter(options);
  const { kysely: db } = await createKyselyAdapter(options);
  const baseURL = getBaseURL(options.baseURL, options.basePath) || "";
  const secret = options.secret || process.env.BETTER_AUTH_SECRET || process.env.AUTH_SECRET || DEFAULT_SECRET;
  options = {
    ...options,
    secret,
    baseURL: baseURL ? new URL(baseURL).origin : "",
    basePath: options.basePath || "/api/auth",
    plugins: plugins.concat(internalPlugins)
  };
  const cookies = getCookies(options);
  const tables = getAuthTables(options);
  const socialProviders = Object.keys(options.socialProviders || {}).map((key) => {
    const value = options.socialProviders?.[key];
    if (value.enabled === false) {
      return null;
    }
    if (!value.clientId || !value.clientSecret) {
      logger.warn(
        `Social provider ${key} is missing clientId or clientSecret`
      );
    }
    return oAuthProviders[key](value);
  }).filter((x) => x !== null);
  return {
    appName: options.appName || "Better Auth",
    socialProviders,
    options,
    tables,
    baseURL,
    sessionConfig: {
      updateAge: options.session?.updateAge || 24 * 60 * 60,
      // 24 hours
      expiresIn: options.session?.expiresIn || 60 * 60 * 24 * 7
      // 7 days
    },
    secret,
    rateLimit: {
      ...options.rateLimit,
      enabled: options.rateLimit?.enabled ?? process.env.NODE_ENV !== "development",
      window: options.rateLimit?.window || 60,
      max: options.rateLimit?.max || 100,
      storage: options.rateLimit?.storage || "memory"
    },
    authCookies: cookies,
    logger: createLogger({
      disabled: options.logger?.disabled || false
    }),
    db,
    password: {
      hash: options.emailAndPassword?.password?.hash || hashPassword,
      verify: options.emailAndPassword?.password?.verify || verifyPassword,
      config: {
        minPasswordLength: options.emailAndPassword?.minPasswordLength || 8,
        maxPasswordLength: options.emailAndPassword?.maxPasswordLength || 128
      }
    },
    adapter,
    internalAdapter: createInternalAdapter(adapter, {
      options,
      hooks: dbHooks.filter((u) => u !== void 0)
    }),
    createAuthCookie: createCookieGetter(options),
    ...context
  };
};
function runPluginInit(options) {
  const plugins = options.plugins || [];
  let context = {};
  const dbHooks = [options.databaseHooks];
  for (const plugin of plugins) {
    if (plugin.init) {
      const result = plugin.init(options);
      if (typeof result === "object") {
        if (result.options) {
          if (result.options.databaseHooks) {
            dbHooks.push(result.options.databaseHooks);
          }
          options = defu(options, result.options);
        }
        if (result.context) {
          context = defu(context, result.context);
        }
      }
    }
  }
  return {
    options,
    context,
    dbHooks
  };
}
function getInternalPlugins(options) {
  const plugins = [];
  if (options.advanced?.crossSubDomainCookies?.enabled) {
    plugins.push(
      crossSubdomainCookies({
        eligibleCookies: options.advanced.crossSubDomainCookies.eligibleCookies
      })
    );
  }
  return plugins;
}

// src/auth.ts
var betterAuth = (options) => {
  const authContext = init(options);
  const { api } = getEndpoints(authContext, options);
  return {
    handler: async (request) => {
      const ctx = await authContext;
      const basePath = ctx.options.basePath;
      const url = new URL(request.url);
      if (!ctx.options.baseURL) {
        const baseURL = `${url.origin}/api/auth`;
        ctx.options.baseURL = baseURL;
        ctx.baseURL = baseURL;
      }
      if (!ctx.options.baseURL) {
        return new Response("Base URL not set", { status: 400 });
      }
      if (url.pathname === basePath || url.pathname === `${basePath}/`) {
        return new Response("Welcome to BetterAuth", { status: 200 });
      }
      const { handler } = router(ctx, options);
      return handler(request);
    },
    api,
    options,
    $Infer: {}
  };
};
export {
  betterAuth
};
