// src/adapters/drizzle-adapter/index.ts
import { and, eq, or } from "drizzle-orm";

// src/db/get-tables.ts
var getAuthTables = (options) => {
  const pluginSchema = options.plugins?.reduce(
    (acc, plugin) => {
      const schema = plugin.schema;
      if (!schema) return acc;
      for (const [key, value] of Object.entries(schema)) {
        acc[key] = {
          fields: {
            ...acc[key]?.fields,
            ...value.fields
          },
          tableName: key
        };
      }
      return acc;
    },
    {}
  );
  const shouldAddRateLimitTable = options.rateLimit?.storage === "database";
  const rateLimitTable = {
    rateLimit: {
      tableName: options.rateLimit?.tableName || "rateLimit",
      fields: {
        key: {
          type: "string"
        },
        count: {
          type: "number"
        },
        lastRequest: {
          type: "number"
        }
      }
    }
  };
  const { user, session, account, ...pluginTables } = pluginSchema || {};
  const accountFields = options.account?.fields;
  const userFields = options.user?.fields;
  return {
    user: {
      tableName: options.user?.modelName || "user",
      fields: {
        [userFields?.name || "name"]: {
          type: "string",
          required: true
        },
        email: {
          type: "string",
          unique: true,
          required: true
        },
        emailVerified: {
          type: "boolean",
          defaultValue: () => false,
          required: true
        },
        image: {
          type: "string",
          required: false
        },
        createdAt: {
          type: "date",
          defaultValue: () => /* @__PURE__ */ new Date(),
          required: true
        },
        updatedAt: {
          type: "date",
          defaultValue: () => /* @__PURE__ */ new Date(),
          required: true
        },
        ...user?.fields
      },
      order: 0
    },
    session: {
      tableName: options.session?.modelName || "session",
      fields: {
        expiresAt: {
          type: "date",
          required: true
        },
        ipAddress: {
          type: "string",
          required: false
        },
        userAgent: {
          type: "string",
          required: false
        },
        userId: {
          type: "string",
          references: {
            model: options.user?.modelName || "user",
            field: "id",
            onDelete: "cascade"
          },
          required: true
        },
        ...session?.fields
      },
      order: 1
    },
    account: {
      tableName: options.account?.modelName || "account",
      fields: {
        [accountFields?.accountId || "accountId"]: {
          type: "string",
          required: true
        },
        providerId: {
          type: "string",
          required: true
        },
        userId: {
          type: "string",
          references: {
            model: options.user?.modelName || "user",
            field: "id",
            onDelete: "cascade"
          },
          required: true
        },
        accessToken: {
          type: "string",
          required: false
        },
        refreshToken: {
          type: "string",
          required: false
        },
        idToken: {
          type: "string",
          required: false
        },
        expiresAt: {
          type: "date",
          required: false
        },
        password: {
          type: "string",
          required: false
        },
        ...account?.fields
      },
      order: 2
    },
    verification: {
      tableName: options.verification?.modelName || "verification",
      fields: {
        identifier: {
          type: "string",
          required: true
        },
        value: {
          type: "string",
          required: true
        },
        expiresAt: {
          type: "date",
          required: true
        }
      }
    },
    ...pluginTables,
    ...shouldAddRateLimitTable ? rateLimitTable : {}
  };
};

// src/adapters/drizzle-adapter/index.ts
import { existsSync } from "fs";
import "fs/promises";

// src/error/better-auth-error.ts
var BetterAuthError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.name = "BetterAuthError";
    this.message = message;
    this.cause = cause;
    this.stack = "";
  }
};

// src/adapters/drizzle-adapter/index.ts
import "chalk";
function getSchema(modelName, options) {
  const schema = options.schema;
  if (!schema) {
    throw new BetterAuthError(
      "Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object."
    );
  }
  const model = options.usePlural ? `${modelName}s` : modelName;
  const schemaModel = schema[model];
  if (!schemaModel) {
    throw new BetterAuthError(
      `[# Drizzle Adapter]: The model "${modelName}" was not found in the schema object. Please pass the schema directly to the adapter options.`
    );
  }
  return schemaModel;
}
function whereConvertor(where, schemaModel) {
  if (!where) return [];
  if (where.length === 1) {
    const w = where[0];
    if (!w) {
      return [];
    }
    return [eq(schemaModel[w.field], w.value)];
  }
  const andGroup = where.filter((w) => w.connector === "AND" || !w.connector);
  const orGroup = where.filter((w) => w.connector === "OR");
  const andClause = and(
    ...andGroup.map((w) => {
      return eq(schemaModel[w.field], w.value);
    })
  );
  const orClause = or(
    ...orGroup.map((w) => {
      return eq(schemaModel[w.field], w.value);
    })
  );
  const clause = [];
  if (andGroup.length) clause.push(andClause);
  if (orGroup.length) clause.push(orClause);
  return clause;
}
var drizzleAdapter = (db, options) => {
  const schema = options.schema || db._.fullSchema;
  const databaseType = options?.provider;
  return {
    id: "drizzle",
    async create(data) {
      const { model, data: val } = data;
      const schemaModel = getSchema(model, {
        schema,
        usePlural: options.usePlural
      });
      const res = await db.insert(schemaModel).values(val).returning();
      return res[0];
    },
    async findOne(data) {
      const { model, where, select: included } = data;
      const schemaModel = getSchema(model, {
        schema,
        usePlural: options.usePlural
      });
      const wheres = whereConvertor(where, schemaModel);
      let res = null;
      if (!!included?.length) {
        res = await db.select(
          ...included.map((include) => {
            return {
              [include]: schemaModel[include]
            };
          })
        ).from(schemaModel).where(...wheres);
      } else {
        res = await db.select().from(schemaModel).where(...wheres);
      }
      if (!!res.length) return res[0];
      else return null;
    },
    async findMany(data) {
      const { model, where } = data;
      const schemaModel = getSchema(model, {
        schema,
        usePlural: options.usePlural
      });
      const wheres = where ? whereConvertor(where, schemaModel) : [];
      if (!wheres.length) {
        return await db.select().from(schemaModel);
      }
      const res = await db.select().from(schemaModel).where(...wheres);
      return res;
    },
    async update(data) {
      const { model, where, update } = data;
      const schemaModel = getSchema(model, {
        schema,
        usePlural: options.usePlural
      });
      const wheres = whereConvertor(where, schemaModel);
      const res = await db.update(schemaModel).set(update).where(...wheres).returning();
      return res[0];
    },
    async delete(data) {
      const { model, where } = data;
      const schemaModel = getSchema(model, {
        schema,
        usePlural: options.usePlural
      });
      const wheres = whereConvertor(where, schemaModel);
      const res = await db.delete(schemaModel).where(...wheres);
      return res[0];
    },
    async createSchema(options2, file) {
      const tables = getAuthTables(options2);
      const filePath = file || "./auth-schema.ts";
      const timestampAndBoolean = databaseType !== "sqlite" ? "timestamp, boolean" : "";
      const int = databaseType === "mysql" ? "int" : "integer";
      let code = `import { ${databaseType}Table, text, ${int}, ${timestampAndBoolean} } from "drizzle-orm/${databaseType}-core";
			`;
      const fileExist = existsSync(filePath);
      for (const table in tables) {
        let getType2 = function(name, type) {
          if (type === "string") {
            return `text('${name}')`;
          }
          if (type === "number") {
            return `${int}('${name}')`;
          }
          if (type === "boolean") {
            if (databaseType === "sqlite") {
              return `integer('${name}', {
								mode: "boolean"
							})`;
            }
            return `boolean('${name}')`;
          }
          if (type === "date") {
            if (databaseType === "sqlite") {
              return `integer('${name}', {
								mode: "timestamp"
							})`;
            }
            return `timestamp('${name}')`;
          }
        };
        var getType = getType2;
        const tableName = tables[table].tableName;
        const fields = tables[table].fields;
        const schema2 = `export const ${table} = ${databaseType}Table("${tableName}", {
					id: text("id").primaryKey(),
					${Object.keys(fields).map((field) => {
          const attr = fields[field];
          return `${field}: ${getType2(field, attr.type)}${attr.required ? ".notNull()" : ""}${attr.unique ? ".unique()" : ""}${attr.references ? `.references(()=> ${attr.references.model}.${attr.references.field})` : ""}`;
        }).join(",\n ")}
				});`;
        code += `
${schema2}
`;
      }
      return {
        code,
        fileName: filePath,
        overwrite: fileExist
      };
    }
  };
};
export {
  drizzleAdapter
};
