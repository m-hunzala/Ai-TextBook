import { b as BetterAuthPlugin, a as Auth, F as FieldAttribute, I as InferFieldOutput } from './index-PjYlcsPD.js';
export { A as Adapter, k as AuthContext, B as BetterAuthOptions, G as GenericEndpointContext, H as HookEndpointContext, i as InferPluginTypes, h as InferSession, g as InferUser, P as PluginSchema, R as RateLimit, S as SessionAdapter, W as Where, j as init } from './index-PjYlcsPD.js';
import { U as UnionToIntersection, H as HasRequiredKeys, P as Prettify, S as StripEmptyObjects, L as LiteralString } from './helper-DPDj8Nix.js';
export { D as DeepPartial, a as LiteralUnion, R as RequiredKeysOf, W as WithoutEmpty } from './helper-DPDj8Nix.js';
import { S as Session, U as User } from './index-JM-i6hLs.js';
export { O as OAuthProvider, f as OAuthProviderList, P as ProviderOptions } from './index-JM-i6hLs.js';
import { BetterFetchOption, BetterFetchResponse, BetterFetch, BetterFetchPlugin } from '@better-fetch/fetch';
import { Atom } from 'nanostores';
import { Endpoint, Context } from 'better-call';
import 'kysely';
import 'arctic';
import 'zod';
import 'better-sqlite3';
import 'mysql2';

type CamelCase<S extends string> = S extends `${infer P1}-${infer P2}${infer P3}` ? `${Lowercase<P1>}${Uppercase<P2>}${CamelCase<P3>}` : Lowercase<S>;
type PathToObject<T extends string, Fn extends (...args: any[]) => any> = T extends `/${infer Segment}/${infer Rest}` ? {
    [K in CamelCase<Segment>]: PathToObject<`/${Rest}`, Fn>;
} : T extends `/${infer Segment}` ? {
    [K in CamelCase<Segment>]: Fn;
} : never;
type InferCtx<C extends Context<any, any>> = C["body"] extends Record<string, any> ? C["body"] & {
    fetchOptions?: BetterFetchOption<undefined, C["query"], C["params"]>;
} : C["query"] extends Record<string, any> ? {
    query: C["query"];
    fetchOptions?: Omit<BetterFetchOption<C["body"], C["query"], C["params"]>, "query">;
} : {
    fetchOptions?: BetterFetchOption<C["body"], C["query"], C["params"]>;
};
type MergeRoutes<T> = UnionToIntersection<T>;
type InferReturn<R, O extends ClientOptions> = R extends {
    user: any;
} | {
    session: any;
} | {
    user: any;
    session: any;
} ? StripEmptyObjects<{
    user: InferUserFromClient<O>;
    session: InferSessionFromClient<O>;
} & {
    [key in Exclude<keyof R, "user" | "session">]: R[key];
}> : R;
type InferRoute<API, COpts extends ClientOptions> = API extends {
    [key: string]: infer T;
} ? T extends Endpoint ? T["options"]["metadata"] extends {
    isAction: false;
} ? {} : PathToObject<T["path"], T extends (ctx: infer C) => infer R ? C extends Context<any, any> ? (...data: HasRequiredKeys<InferCtx<C>> extends true ? [
    Prettify<InferCtx<C>>,
    BetterFetchOption<C["body"], C["query"], C["params"]>?
] : [
    Prettify<InferCtx<C>>?,
    BetterFetchOption<C["body"], C["query"], C["params"]>?
]) => Promise<BetterFetchResponse<InferReturn<Awaited<R>, COpts>>> : never : never> : never : never;
type InferRoutes<API extends Record<string, Endpoint>, ClientOpts extends ClientOptions> = MergeRoutes<InferRoute<API, ClientOpts>>;

type AtomListener = {
    matcher: (path: string) => boolean;
    signal: "_sessionSignal" | Omit<string, "_sessionSignal">;
};
interface BetterAuthClientPlugin {
    id: LiteralString;
    /**
     * only used for type inference. don't pass the
     * actual plugin
     */
    $InferServerPlugin?: BetterAuthPlugin;
    /**
     * Custom actions
     */
    getActions?: ($fetch: BetterFetch) => Record<string, any>;
    /**
     * State atoms that'll be resolved by each framework
     * auth store.
     */
    getAtoms?: ($fetch: BetterFetch) => Record<string, Atom<any>>;
    /**
     * specify path methods for server plugin inferred
     * endpoints to force a specific method.
     */
    pathMethods?: Record<string, "POST" | "GET">;
    /**
     * Better fetch plugins
     */
    fetchPlugins?: BetterFetchPlugin[];
    /**
     * a list of recaller based on a matcher function.
     * The signal name needs to match a signal in this
     * plugin or any plugin the user might have added.
     */
    atomListeners?: AtomListener[];
}
interface ClientOptions {
    fetchOptions?: BetterFetchOption;
    plugins?: BetterAuthClientPlugin[];
    baseURL?: string;
}
type InferClientAPI<O extends ClientOptions> = InferRoutes<O["plugins"] extends Array<any> ? (O["plugins"] extends Array<infer Pl> ? UnionToIntersection<Pl extends {
    $InferServerPlugin: infer Plug;
} ? Plug extends BetterAuthPlugin ? Plug["endpoints"] : {} : {}> : {}) & Auth["api"] : Auth["api"], O>;
type InferActions<O extends ClientOptions> = O["plugins"] extends Array<infer Plugin> ? UnionToIntersection<Plugin extends BetterAuthClientPlugin ? Plugin["getActions"] extends ($fetch: BetterFetch) => infer Actions ? Actions : {} : {}> : {};
/**
 * signals are just used to recall a computed value. as a
 * convention they start with "_"
 */
type IsSignal<T> = T extends `_${infer _}` ? true : false;
type InferPluginsFromClient<O extends ClientOptions> = O["plugins"] extends Array<BetterAuthClientPlugin> ? Array<O["plugins"][number]["$InferServerPlugin"]> : undefined;
type InferSessionFromClient<O extends ClientOptions> = StripEmptyObjects<Session & UnionToIntersection<InferAdditionalFromClient<O, "session">>>;
type InferUserFromClient<O extends ClientOptions> = StripEmptyObjects<User & UnionToIntersection<InferAdditionalFromClient<O, "user">>>;
type InferAdditionalFromClient<Options extends ClientOptions, Key extends string> = Options["plugins"] extends Array<infer T> ? T extends BetterAuthClientPlugin ? T["$InferServerPlugin"] extends {
    schema: {
        [key in Key]: {
            fields: infer Field;
        };
    };
} ? Field extends Record<infer Key, FieldAttribute> ? {
    [key in Key as Field[key]["required"] extends false ? never : Field[key]["defaultValue"] extends boolean | string | number | Date | Function ? key : never]: InferFieldOutput<Field[key]>;
} & {
    [key in Key as Field[key]["returned"] extends false ? never : key]?: InferFieldOutput<Field[key]>;
} : {} : {} : {} : {};

export { type AtomListener, type BetterAuthClientPlugin, BetterAuthPlugin, type ClientOptions, HasRequiredKeys, type InferActions, type InferAdditionalFromClient, type InferClientAPI, type InferPluginsFromClient, type InferSessionFromClient, type InferUserFromClient, type IsSignal, LiteralString, Prettify, Session, StripEmptyObjects, UnionToIntersection, User };
