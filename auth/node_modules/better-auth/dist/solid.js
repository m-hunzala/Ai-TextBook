// src/client/solid.ts
import { useStore } from "@nanostores/solid";

// src/client/config.ts
import { createFetch } from "@better-fetch/fetch";

// src/error/better-auth-error.ts
var BetterAuthError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.name = "BetterAuthError";
    this.message = message;
    this.cause = cause;
    this.stack = "";
  }
};

// src/utils/base-url.ts
function checkHasPath(url) {
  try {
    const parsedUrl = new URL(url);
    return parsedUrl.pathname !== "/";
  } catch (error) {
    throw new BetterAuthError(
      `Invalid base URL: ${url}. Please provide a valid base URL.`
    );
  }
}
function withPath(url, path = "/api/auth") {
  const hasPath = checkHasPath(url);
  if (hasPath) {
    return url;
  }
  path = path.startsWith("/") ? path : `/${path}`;
  return `${url}${path}`;
}
function getBaseURL(url, path) {
  if (url) {
    return withPath(url, path);
  }
  const env = typeof process !== "undefined" ? process.env : {};
  const fromEnv = env.BETTER_AUTH_URL || env.NEXT_PUBLIC_BETTER_AUTH_URL || env.PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_AUTH_URL || (env.BASE_URL !== "/" ? env.BASE_URL : void 0);
  if (fromEnv) {
    return withPath(fromEnv, path);
  }
  if (typeof window !== "undefined") {
    return withPath(window.location.origin, path);
  }
  return void 0;
}

// src/client/config.ts
import "nanostores";

// src/client/fetch-plugins.ts
import { betterFetch } from "@better-fetch/fetch";
var redirectPlugin = {
  id: "redirect",
  name: "Redirect",
  hooks: {
    onSuccess(context) {
      if (context.data?.url && context.data?.redirect) {
        if (typeof window !== "undefined") {
          window.location.href = context.data.url;
        }
      }
    }
  }
};
var addCurrentURL = {
  id: "add-current-url",
  name: "Add current URL",
  hooks: {
    onRequest(context) {
      if (typeof window !== "undefined") {
        const url = new URL(context.url);
        url.searchParams.set("currentURL", window.location.href);
        context.url = url;
      }
      return context;
    }
  }
};
var cache = /* @__PURE__ */ new Map();
var csrfPlugin = {
  id: "csrf",
  name: "CSRF Check",
  async init(url, options) {
    if (!options?.baseURL) {
      throw new BetterAuthError(
        "API Base URL on the auth client isn't configured. Please pass it directly to the client `baseURL`"
      );
    }
    if (options?.method !== "GET") {
      options = options || {};
      const csrfToken = cache.get("CSRF_TOKEN");
      if (!csrfToken) {
        const { data, error } = await betterFetch("/csrf", {
          body: void 0,
          baseURL: options.baseURL,
          plugins: [],
          method: "GET",
          credentials: "include",
          customFetchImpl: options.customFetchImpl
        });
        if (error) {
          if (error.status === 404) {
            throw new BetterAuthError(
              "CSRF route not found. Make sure the server is running and the base URL is correct and includes the path (e.g. http://localhost:3000/api/auth)."
            );
          }
          if (error.status === 429) {
            return new Response(
              JSON.stringify({
                message: "Too many requests. Please try again later."
              }),
              {
                status: 429,
                statusText: "Too Many Requests"
              }
            );
          }
          throw new BetterAuthError(
            "Failed to fetch CSRF token: " + error.message
          );
        }
        cache.set("CSRF_TOKEN", data.csrfToken);
      }
      options.body = {
        ...options?.body,
        csrfToken
      };
    }
    options.credentials = "include";
    return { url, options };
  }
};

// src/client/config.ts
var getClientConfig = (options) => {
  const $fetch = createFetch({
    baseURL: getBaseURL(options?.fetchOptions?.baseURL || options?.baseURL),
    credentials: "include",
    ...options?.fetchOptions,
    plugins: [
      csrfPlugin,
      redirectPlugin,
      addCurrentURL,
      ...options?.fetchOptions?.plugins?.filter((pl) => pl !== void 0) || [],
      ...options?.plugins?.flatMap((plugin) => plugin.fetchPlugins).filter((pl) => pl !== void 0) || []
    ]
  });
  const plugins = options?.plugins || [];
  let pluginsActions = {};
  let pluginsAtoms = {};
  let pluginPathMethods = {
    "/sign-out": "POST",
    "/user/revoke-sessions": "POST"
  };
  const atomListeners = [
    {
      signal: "_sessionSignal",
      matcher(path) {
        return path === "/sign-out" || path === "/user/update" || path.startsWith("/sign-in") || path.startsWith("/sign-up");
      }
    }
  ];
  for (const plugin of plugins) {
    if (plugin.getActions) {
      Object.assign(pluginsActions, plugin.getActions?.($fetch));
    }
    if (plugin.getAtoms) {
      Object.assign(pluginsAtoms, plugin.getAtoms?.($fetch));
    }
    if (plugin.pathMethods) {
      Object.assign(pluginPathMethods, plugin.pathMethods);
    }
    if (plugin.atomListeners) {
      atomListeners.push(...plugin.atomListeners);
    }
  }
  return {
    pluginsActions,
    pluginsAtoms,
    pluginPathMethods,
    atomListeners,
    $fetch
  };
};

// src/client/proxy.ts
function getMethod(path, knownPathMethods, args) {
  const method = knownPathMethods[path];
  const { fetchOptions, query, ...body } = args || {};
  if (method) {
    return method;
  }
  if (fetchOptions?.method) {
    return fetchOptions.method;
  }
  if (body && Object.keys(body).length > 0) {
    return "POST";
  }
  return "GET";
}
function createDynamicPathProxy(routes, client, knownPathMethods, atoms, atomListeners) {
  function createProxy(path = []) {
    return new Proxy(function() {
    }, {
      get(target, prop) {
        const fullPath = [...path, prop];
        let current = routes;
        for (const segment of fullPath) {
          if (current && typeof current === "object" && segment in current) {
            current = current[segment];
          } else {
            current = void 0;
            break;
          }
        }
        if (typeof current === "function") {
          return current;
        }
        return createProxy(fullPath);
      },
      apply: async (_, __, args) => {
        const routePath = "/" + path.map(
          (segment) => segment.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`)
        ).join("/");
        const arg = args[0] || {};
        const fetchOptions = args[1] || {};
        const { query, fetchOptions: argFetchOptions, ...body } = arg;
        const options = {
          ...fetchOptions,
          ...argFetchOptions
        };
        const method = getMethod(routePath, knownPathMethods, arg);
        return await client(routePath, {
          ...options,
          body: method === "GET" ? void 0 : {
            ...body,
            ...options?.body || {}
          },
          query: query || options?.query,
          method,
          async onSuccess(context) {
            await options?.onSuccess?.(context);
            const matches = atomListeners?.find((s) => s.matcher(routePath));
            if (!matches) return;
            const signal = atoms[matches.signal];
            if (!signal) return;
            const val = signal.get();
            setTimeout(() => {
              signal.set(!val);
            }, 10);
          }
        });
      }
    });
  }
  return createProxy();
}

// src/utils/misc.ts
function capitalizeFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// src/client/session-atom.ts
import { atom as atom2 } from "nanostores";

// src/client/query.ts
import "@better-fetch/fetch";
import { atom, onMount } from "nanostores";
var useAuthQuery = (initializedAtom, path, $fetch, options) => {
  const value = atom({
    data: null,
    error: null,
    isPending: false,
    isRefetching: false
  });
  const fn = () => {
    const opts = typeof options === "function" ? options({
      data: value.get().data,
      error: value.get().error,
      isPending: value.get().isPending
    }) : options;
    return $fetch(path, {
      ...opts,
      onSuccess: async (context) => {
        value.set({
          data: context.data,
          error: null,
          isPending: false,
          isRefetching: false
        });
        await opts?.onSuccess?.(context);
      },
      async onError(context) {
        value.set({
          error: context.error,
          data: null,
          isPending: false,
          isRefetching: false
        });
        await opts?.onError?.(context);
      },
      async onRequest(context) {
        const currentValue = value.get();
        value.set({
          isPending: currentValue.data === null,
          data: currentValue.data,
          error: null,
          isRefetching: true
        });
        await opts?.onRequest?.(context);
      }
    });
  };
  initializedAtom = Array.isArray(initializedAtom) ? initializedAtom : [initializedAtom];
  let isMounted = false;
  for (const initAtom of initializedAtom) {
    initAtom.subscribe(() => {
      if (isMounted) {
        fn();
      } else {
        onMount(value, () => {
          fn();
          isMounted = true;
          return () => {
            value.off();
            initAtom.off();
          };
        });
      }
    });
  }
  return value;
};

// src/client/session-atom.ts
function getSessionAtom($fetch) {
  const $signal = atom2(false);
  const session = useAuthQuery($signal, "/session", $fetch, {
    method: "GET"
  });
  return {
    $session: session,
    _sessionSignal: $signal,
    $Infer: {}
  };
}

// src/client/solid.ts
function getAtomKey(str) {
  return `use${capitalizeFirstLetter(str)}`;
}
function createAuthClient(options) {
  const {
    pluginPathMethods,
    pluginsActions,
    pluginsAtoms,
    $fetch,
    atomListeners
  } = getClientConfig(options);
  let resolvedHooks = {};
  for (const [key, value] of Object.entries(pluginsAtoms)) {
    resolvedHooks[getAtomKey(key)] = () => useStore(value);
  }
  const { $session, _sessionSignal, $Infer } = getSessionAtom($fetch);
  function useSession() {
    return useStore($session);
  }
  const routes = {
    ...pluginsActions,
    ...resolvedHooks,
    useSession
  };
  const proxy = createDynamicPathProxy(
    routes,
    $fetch,
    pluginPathMethods,
    {
      ...pluginsAtoms,
      _sessionSignal
    },
    atomListeners
  );
  return proxy;
}
export {
  createAuthClient
};
