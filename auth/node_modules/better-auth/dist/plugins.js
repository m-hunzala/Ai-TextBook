var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/plugins/organization/organization.ts
import { APIError as APIError7 } from "better-call";
import {
  z as z16
} from "zod";

// src/api/call.ts
import {
  createEndpointCreator,
  createMiddleware,
  createMiddlewareCreator
} from "better-call";
var optionsMiddleware = createMiddleware(async () => {
  return {};
});
var createAuthMiddleware = createMiddlewareCreator({
  use: [
    optionsMiddleware,
    /**
     * Only use for post hooks
     */
    createMiddleware(async () => {
      return {};
    })
  ]
});
var createAuthEndpoint = createEndpointCreator({
  use: [optionsMiddleware]
});

// src/api/routes/sign-in.ts
import { APIError as APIError2 } from "better-call";
import { generateCodeVerifier } from "oslo/oauth2";
import { z as z3 } from "zod";

// src/social-providers/apple.ts
import "arctic";
import { parseJWT } from "oslo/jwt";
import "@better-fetch/fetch";

// src/error/better-auth-error.ts
var BetterAuthError = class extends Error {
  constructor(message, cause) {
    super(message);
    this.name = "BetterAuthError";
    this.message = message;
    this.cause = cause;
    this.stack = "";
  }
};

// src/social-providers/utils.ts
import { OAuth2Tokens } from "arctic";

// src/utils/base-url.ts
function checkHasPath(url) {
  try {
    const parsedUrl = new URL(url);
    return parsedUrl.pathname !== "/";
  } catch (error2) {
    throw new BetterAuthError(
      `Invalid base URL: ${url}. Please provide a valid base URL.`
    );
  }
}
function withPath(url, path = "/api/auth") {
  const hasPath = checkHasPath(url);
  if (hasPath) {
    return url;
  }
  path = path.startsWith("/") ? path : `/${path}`;
  return `${url}${path}`;
}
function getBaseURL(url, path) {
  if (url) {
    return withPath(url, path);
  }
  const env = typeof process !== "undefined" ? process.env : {};
  const fromEnv = env.BETTER_AUTH_URL || env.NEXT_PUBLIC_BETTER_AUTH_URL || env.PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_AUTH_URL || (env.BASE_URL !== "/" ? env.BASE_URL : void 0);
  if (fromEnv) {
    return withPath(fromEnv, path);
  }
  if (typeof window !== "undefined") {
    return withPath(window.location.origin, path);
  }
  return void 0;
}

// src/social-providers/utils.ts
import { betterFetch } from "@better-fetch/fetch";
function getRedirectURI(providerId, redirectURI) {
  return redirectURI || `${getBaseURL()}/callback/${providerId}`;
}
async function validateAuthorizationCode({
  code,
  codeVerifier,
  redirectURI,
  options,
  tokenEndpoint
}) {
  const body = new URLSearchParams();
  body.set("grant_type", "authorization_code");
  body.set("code", code);
  codeVerifier && body.set("code_verifier", codeVerifier);
  body.set("redirect_uri", redirectURI);
  body.set("client_id", options.clientId);
  body.set("client_secret", options.clientSecret);
  const { data, error: error2 } = await betterFetch(tokenEndpoint, {
    method: "POST",
    body,
    headers: {
      "content-type": "application/x-www-form-urlencoded",
      accept: "application/json",
      "user-agent": "better-auth"
    }
  });
  if (error2) {
    throw error2;
  }
  const tokens = new OAuth2Tokens(data);
  return tokens;
}

// src/social-providers/apple.ts
var apple = (options) => {
  const tokenEndpoint = "https://appleid.apple.com/auth/token";
  return {
    id: "apple",
    name: "Apple",
    createAuthorizationURL({ state, scopes, redirectURI }) {
      const _scope = scopes || ["email", "name", "openid"];
      return new URL(
        `https://appleid.apple.com/auth/authorize?client_id=${options.clientId}&response_type=code&redirect_uri=${redirectURI || options.redirectURI}&scope=${_scope.join(" ")}&state=${state}`
      );
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: redirectURI || getRedirectURI("apple", options.redirectURI),
        options,
        tokenEndpoint
      });
    },
    async getUserInfo(token) {
      const data = parseJWT(token.idToken())?.payload;
      if (!data) {
        return null;
      }
      return {
        user: {
          id: data.sub,
          name: data.name,
          email: data.email,
          emailVerified: data.email_verified === "true"
        },
        data
      };
    }
  };
};

// src/social-providers/discord.ts
import { betterFetch as betterFetch3 } from "@better-fetch/fetch";
var discord = (options) => {
  return {
    id: "discord",
    name: "Discord",
    createAuthorizationURL({ state, scopes }) {
      const _scopes = scopes || ["identify", "email"];
      return new URL(
        `https://discord.com/api/oauth2/authorize?scope=${_scopes.join(
          "+"
        )}&response_type=code&client_id=${options.clientId}&redirect_uri=${encodeURIComponent(
          getRedirectURI("discord", options.redirectURI)
        )}&state=${state}`
      );
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        redirectURI: redirectURI || getRedirectURI("discord", options.redirectURI),
        options,
        tokenEndpoint: "https://discord.com/api/oauth2/token"
      });
    },
    async getUserInfo(token) {
      const { data: profile, error: error2 } = await betterFetch3(
        "https://discord.com/api/users/@me",
        {
          headers: {
            authorization: `Bearer ${token.accessToken()}`
          }
        }
      );
      if (error2) {
        return null;
      }
      if (profile.avatar === null) {
        const defaultAvatarNumber = profile.discriminator === "0" ? Number(BigInt(profile.id) >> BigInt(22)) % 6 : parseInt(profile.discriminator) % 5;
        profile.image_url = `https://cdn.discordapp.com/embed/avatars/${defaultAvatarNumber}.png`;
      } else {
        const format = profile.avatar.startsWith("a_") ? "gif" : "png";
        profile.image_url = `https://cdn.discordapp.com/avatars/${profile.id}/${profile.avatar}.${format}`;
      }
      return {
        user: {
          id: profile.id,
          name: profile.display_name || profile.username || "",
          email: profile.email,
          emailVerified: profile.verified,
          image: profile.image_url
        },
        data: profile
      };
    }
  };
};

// src/social-providers/facebook.ts
import { betterFetch as betterFetch4 } from "@better-fetch/fetch";
import { Facebook } from "arctic";
var facebook = (options) => {
  const facebookArctic = new Facebook(
    options.clientId,
    options.clientSecret,
    getRedirectURI("facebook", options.redirectURI)
  );
  return {
    id: "facebook",
    name: "Facebook",
    createAuthorizationURL({ state, scopes }) {
      const _scopes = scopes || ["email", "public_profile"];
      return facebookArctic.createAuthorizationURL(state, _scopes);
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: redirectURI || getRedirectURI("facebook", options.redirectURI),
        options,
        tokenEndpoint: "https://graph.facebook.com/v16.0/oauth/access_token"
      });
    },
    async getUserInfo(token) {
      const { data: profile, error: error2 } = await betterFetch4(
        "https://graph.facebook.com/me",
        {
          auth: {
            type: "Bearer",
            token: token.accessToken()
          }
        }
      );
      if (error2) {
        return null;
      }
      return {
        user: {
          id: profile.id,
          name: profile.name,
          email: profile.email,
          emailVerified: profile.email_verified
        },
        data: profile
      };
    }
  };
};

// src/social-providers/github.ts
import { betterFetch as betterFetch5 } from "@better-fetch/fetch";
import { GitHub } from "arctic";
var github = ({
  clientId,
  clientSecret,
  redirectURI
}) => {
  const githubArctic = new GitHub(
    clientId,
    clientSecret,
    getRedirectURI("github", redirectURI)
  );
  return {
    id: "github",
    name: "Github",
    createAuthorizationURL({ state, scopes }) {
      const _scopes = scopes || ["user:email"];
      return githubArctic.createAuthorizationURL(state, _scopes);
    },
    validateAuthorizationCode: async (state) => {
      return await githubArctic.validateAuthorizationCode(state);
    },
    async getUserInfo(token) {
      const { data: profile, error: error2 } = await betterFetch5(
        "https://api.github.com/user",
        {
          auth: {
            type: "Bearer",
            token: token.accessToken()
          }
        }
      );
      if (error2) {
        return null;
      }
      let emailVerified = false;
      if (!profile.email) {
        const { data, error: error3 } = await betterFetch5("https://api.github.com/user/emails", {
          auth: {
            type: "Bearer",
            token: token.accessToken()
          }
        });
        if (!error3) {
          profile.email = (data.find((e) => e.primary) ?? data[0])?.email;
          emailVerified = data.find((e) => e.email === profile.email)?.verified ?? false;
        }
      }
      return {
        user: {
          id: profile.id,
          name: profile.name,
          email: profile.email,
          image: profile.avatar_url,
          emailVerified,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        },
        data: profile
      };
    }
  };
};

// src/social-providers/google.ts
import { Google } from "arctic";
import { parseJWT as parseJWT2 } from "oslo/jwt";

// src/utils/logger.ts
import { createConsola } from "consola";
var consola = createConsola({
  formatOptions: {
    date: false,
    colors: true,
    compact: true
  },
  defaults: {
    tag: "Better Auth"
  }
});
var createLogger = (options) => {
  return {
    log: (...args) => {
      !options?.disabled && consola.log("", ...args);
    },
    error: (...args) => {
      !options?.disabled && consola.error("", ...args);
    },
    warn: (...args) => {
      !options?.disabled && consola.warn("", ...args);
    },
    info: (...args) => {
      !options?.disabled && consola.info("", ...args);
    },
    debug: (...args) => {
      !options?.disabled && consola.debug("", ...args);
    },
    box: (...args) => {
      !options?.disabled && consola.box("", ...args);
    },
    success: (...args) => {
      !options?.disabled && consola.success("", ...args);
    },
    break: (...args) => {
      !options?.disabled && console.log("\n");
    }
  };
};
var logger = createLogger();

// src/social-providers/google.ts
var google = (options) => {
  const googleArctic = new Google(
    options.clientId,
    options.clientSecret,
    getRedirectURI("google", options.redirectURI)
  );
  return {
    id: "google",
    name: "Google",
    createAuthorizationURL({ state, scopes, codeVerifier, redirectURI }) {
      if (!options.clientId || !options.clientSecret) {
        logger.error(
          "Client Id and Client Secret is required for Google. Make sure to provide them in the options."
        );
        throw new BetterAuthError("CLIENT_ID_AND_SECRET_REQUIRED");
      }
      if (!codeVerifier) {
        throw new BetterAuthError("codeVerifier is required for Google");
      }
      const _scopes = scopes || ["email", "profile"];
      const url = googleArctic.createAuthorizationURL(
        state,
        codeVerifier,
        _scopes
      );
      return url;
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: redirectURI || getRedirectURI("google", options.redirectURI),
        options,
        tokenEndpoint: "https://oauth2.googleapis.com/token"
      });
    },
    async getUserInfo(token) {
      if (!token.idToken) {
        return null;
      }
      const user = parseJWT2(token.idToken())?.payload;
      return {
        user: {
          id: user.sub,
          name: user.name,
          email: user.email,
          image: user.picture,
          emailVerified: user.email_verified
        },
        data: user
      };
    }
  };
};

// src/social-providers/spotify.ts
import { betterFetch as betterFetch6 } from "@better-fetch/fetch";
import { Spotify } from "arctic";
var spotify = (options) => {
  const spotifyArctic = new Spotify(
    options.clientId,
    options.clientSecret,
    getRedirectURI("spotify", options.redirectURI)
  );
  return {
    id: "spotify",
    name: "Spotify",
    createAuthorizationURL({ state, scopes }) {
      const _scopes = scopes || ["user-read-email"];
      return spotifyArctic.createAuthorizationURL(state, _scopes);
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: redirectURI || getRedirectURI("spotify", options.redirectURI),
        options,
        tokenEndpoint: "https://accounts.spotify.com/api/token"
      });
    },
    async getUserInfo(token) {
      const { data: profile, error: error2 } = await betterFetch6(
        "https://api.spotify.com/v1/me",
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${token.accessToken()}`
          }
        }
      );
      if (error2) {
        return null;
      }
      return {
        user: {
          id: profile.id,
          name: profile.display_name,
          email: profile.email,
          image: profile.images[0]?.url,
          emailVerified: false
        },
        data: profile
      };
    }
  };
};

// src/social-providers/twitch.ts
import { betterFetch as betterFetch7 } from "@better-fetch/fetch";
import { Twitch } from "arctic";
var twitch = (options) => {
  const twitchArctic = new Twitch(
    options.clientId,
    options.clientSecret,
    getRedirectURI("twitch", options.redirectURI)
  );
  return {
    id: "twitch",
    name: "Twitch",
    createAuthorizationURL({ state, scopes }) {
      const _scopes = scopes || ["activity:write", "read"];
      return twitchArctic.createAuthorizationURL(state, _scopes);
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        redirectURI: redirectURI || getRedirectURI("twitch", options.redirectURI),
        options,
        tokenEndpoint: "https://id.twitch.tv/oauth2/token"
      });
    },
    async getUserInfo(token) {
      const { data: profile, error: error2 } = await betterFetch7(
        "https://api.twitch.tv/helix/users",
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${token.accessToken()}`
          }
        }
      );
      if (error2) {
        return null;
      }
      return {
        user: {
          id: profile.sub,
          name: profile.preferred_username,
          email: profile.email,
          image: profile.picture,
          emailVerified: false
        },
        data: profile
      };
    }
  };
};

// src/social-providers/twitter.ts
import { betterFetch as betterFetch8 } from "@better-fetch/fetch";
import { Twitter } from "arctic";
var twitter = (options) => {
  const twitterArctic = new Twitter(
    options.clientId,
    options.clientSecret,
    getRedirectURI("twitter", options.redirectURI)
  );
  return {
    id: "twitter",
    name: "Twitter",
    createAuthorizationURL(data) {
      const _scopes = data.scopes || ["account_info.read"];
      return twitterArctic.createAuthorizationURL(
        data.state,
        data.codeVerifier,
        _scopes
      );
    },
    validateAuthorizationCode: async (code, codeVerifier, redirectURI) => {
      return validateAuthorizationCode({
        code,
        codeVerifier,
        redirectURI: redirectURI || getRedirectURI("twitch", options.redirectURI),
        options,
        tokenEndpoint: "https://id.twitch.tv/oauth2/token"
      });
    },
    async getUserInfo(token) {
      const { data: profile, error: error2 } = await betterFetch8(
        "https://api.x.com/2/users/me?user.fields=profile_image_url",
        {
          method: "GET",
          headers: {
            Authorization: `Bearer ${token.accessToken()}`
          }
        }
      );
      if (error2) {
        return null;
      }
      if (!profile.data.email) {
        return null;
      }
      return {
        user: {
          id: profile.data.id,
          name: profile.data.name,
          email: profile.data.email,
          image: profile.data.profile_image_url,
          emailVerified: profile.data.verified || false
        },
        data: profile
      };
    }
  };
};

// src/types/provider.ts
import "arctic";

// src/social-providers/index.ts
var oAuthProviders = {
  apple,
  discord,
  facebook,
  github,
  google,
  spotify,
  twitch,
  twitter
};
var oAuthProviderList = Object.keys(oAuthProviders);

// src/utils/state.ts
import { generateState as generateStateOAuth } from "oslo/oauth2";
import { z } from "zod";
function generateState(callbackURL, currentURL, dontRememberMe) {
  const code = generateStateOAuth();
  const state = JSON.stringify({
    code,
    callbackURL,
    currentURL,
    dontRememberMe
  });
  return { state, code };
}
function parseState(state) {
  const data = z.object({
    code: z.string(),
    callbackURL: z.string().optional(),
    currentURL: z.string().optional(),
    dontRememberMe: z.boolean().optional()
  }).safeParse(JSON.parse(state));
  return data;
}

// src/api/routes/session.ts
import { APIError } from "better-call";

// src/utils/date.ts
var getDate = (span, unit = "ms") => {
  const date = /* @__PURE__ */ new Date();
  return new Date(date.getTime() + (unit === "sec" ? span * 1e3 : span));
};

// src/utils/cookies.ts
import { TimeSpan } from "oslo";
async function setSessionCookie(ctx, sessionToken, dontRememberMe, overrides) {
  const options = ctx.context.authCookies.sessionToken.options;
  options.maxAge = dontRememberMe ? void 0 : options.maxAge;
  await ctx.setSignedCookie(
    ctx.context.authCookies.sessionToken.name,
    sessionToken,
    ctx.context.secret,
    options
  );
  if (dontRememberMe) {
    await ctx.setSignedCookie(
      ctx.context.authCookies.dontRememberToken.name,
      "true",
      ctx.context.secret,
      ctx.context.authCookies.dontRememberToken.options
    );
  }
}
function deleteSessionCookie(ctx) {
  ctx.setCookie(ctx.context.authCookies.sessionToken.name, "", {
    maxAge: 0
  });
  ctx.setCookie(ctx.context.authCookies.dontRememberToken.name, "", {
    maxAge: 0
  });
}

// src/api/routes/session.ts
import { z as z2 } from "zod";

// src/utils/get-request-ip.ts
function getIp(req) {
  const testIP = "127.0.0.1";
  if (process.env.NODE_ENV === "test") {
    return testIP;
  }
  const headers = [
    "x-client-ip",
    "x-forwarded-for",
    "cf-connecting-ip",
    "fastly-client-ip",
    "x-real-ip",
    "x-cluster-client-ip",
    "x-forwarded",
    "forwarded-for",
    "forwarded"
  ];
  for (const header of headers) {
    const value = req.headers.get(header);
    if (typeof value === "string") {
      const ip = value.split(",")[0].trim();
      if (ip) return ip;
    }
  }
  return null;
}

// src/api/routes/session.ts
function getRequestUniqueKey(ctx, token) {
  if (!ctx.request) {
    return "";
  }
  const { method, url, headers } = ctx.request;
  const userAgent = ctx.request.headers.get("User-Agent") || "";
  const ip = getIp(ctx.request) || "";
  const headerString = JSON.stringify(headers);
  const uniqueString = `${method}:${url}:${headerString}:${userAgent}:${ip}:${token}`;
  return uniqueString;
}
var getSession = () => createAuthEndpoint(
  "/session",
  {
    method: "GET",
    requireHeaders: true
  },
  async (ctx) => {
    try {
      const sessionCookieToken = await ctx.getSignedCookie(
        ctx.context.authCookies.sessionToken.name,
        ctx.context.secret
      );
      if (!sessionCookieToken) {
        return ctx.json(null, {
          status: 401
        });
      }
      const key = getRequestUniqueKey(ctx, sessionCookieToken);
      const session = await ctx.context.internalAdapter.findSession(sessionCookieToken);
      if (!session || session.session.expiresAt < /* @__PURE__ */ new Date()) {
        deleteSessionCookie(ctx);
        if (session) {
          await ctx.context.internalAdapter.deleteSession(session.session.id);
        }
        return ctx.json(null, {
          status: 401
        });
      }
      const dontRememberMe = await ctx.getSignedCookie(
        ctx.context.authCookies.dontRememberToken.name,
        ctx.context.secret
      );
      if (dontRememberMe) {
        return ctx.json(
          session
        );
      }
      const expiresIn = ctx.context.sessionConfig.expiresIn;
      const updateAge = ctx.context.sessionConfig.updateAge;
      const sessionIsDueToBeUpdatedDate = session.session.expiresAt.valueOf() - expiresIn * 1e3 + updateAge * 1e3;
      const shouldBeUpdated = sessionIsDueToBeUpdatedDate <= Date.now();
      if (shouldBeUpdated) {
        const updatedSession = await ctx.context.internalAdapter.updateSession(
          session.session.id,
          {
            expiresAt: getDate(ctx.context.sessionConfig.expiresIn, "sec")
          }
        );
        if (!updatedSession) {
          deleteSessionCookie(ctx);
          return ctx.json(null, { status: 401 });
        }
        const maxAge = (updatedSession.expiresAt.valueOf() - Date.now()) / 1e3;
        await setSessionCookie(ctx, updatedSession.id, false, {
          maxAge
        });
        return ctx.json({
          session: updatedSession,
          user: session.user
        });
      }
      return ctx.json(
        session
      );
    } catch (error2) {
      ctx.context.logger.error(error2);
      return ctx.json(null, { status: 500 });
    }
  }
);
var getSessionFromCtx = async (ctx) => {
  const session = await getSession()({
    ...ctx,
    //@ts-expect-error: By default since this request context comes from a router it'll have a `router` flag which force it to be a request object
    _flag: void 0
  });
  return session;
};
var sessionMiddleware = createAuthMiddleware(async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session?.session) {
    throw new APIError("UNAUTHORIZED");
  }
  return {
    session
  };
});
var revokeSession = createAuthEndpoint(
  "/user/revoke-session",
  {
    method: "POST",
    body: z2.object({
      id: z2.string()
    }),
    use: [sessionMiddleware],
    requireHeaders: true
  },
  async (ctx) => {
    const id = ctx.body.id;
    const findSession = await ctx.context.internalAdapter.findSession(id);
    if (!findSession) {
      return ctx.json(null, { status: 400 });
    }
    if (findSession.session.userId !== ctx.context.session.user.id) {
      return ctx.json(null, { status: 403 });
    }
    try {
      await ctx.context.internalAdapter.deleteSession(id);
    } catch (error2) {
      ctx.context.logger.error(error2);
      return ctx.json(null, { status: 500 });
    }
    return ctx.json({
      status: true
    });
  }
);
var revokeSessions = createAuthEndpoint(
  "/user/revoke-sessions",
  {
    method: "POST",
    use: [sessionMiddleware],
    requireHeaders: true
  },
  async (ctx) => {
    try {
      await ctx.context.internalAdapter.deleteSessions(
        ctx.context.session.user.id
      );
    } catch (error2) {
      ctx.context.logger.error(error2);
      return ctx.json(null, { status: 500 });
    }
    return ctx.json({
      status: true
    });
  }
);

// src/api/routes/sign-in.ts
var signInOAuth = createAuthEndpoint(
  "/sign-in/social",
  {
    method: "POST",
    requireHeaders: true,
    query: z3.object({
      /**
       * Redirect to the current URL after the
       * user has signed in.
       */
      currentURL: z3.string().optional()
    }).optional(),
    body: z3.object({
      /**
       * Callback URL to redirect to after the user has signed in.
       */
      callbackURL: z3.string().optional(),
      /**
       * OAuth2 provider to use`
       */
      provider: z3.enum(oAuthProviderList),
      /**
       * If this is true the session will only be valid for the current browser session
       */
      dontRememberMe: z3.boolean().default(false).optional()
    })
  },
  async (c) => {
    const provider = c.context.socialProviders.find(
      (p) => p.id === c.body.provider
    );
    if (!provider) {
      c.context.logger.error(
        "Provider not found. Make sure to add the provider to your auth config",
        {
          provider: c.body.provider
        }
      );
      throw new APIError2("NOT_FOUND", {
        message: "Provider not found"
      });
    }
    const cookie = c.context.authCookies;
    const currentURL = c.query?.currentURL ? new URL(c.query?.currentURL) : null;
    const callbackURL = c.body.callbackURL?.startsWith("http") ? c.body.callbackURL : `${currentURL?.origin}${c.body.callbackURL || ""}`;
    const state = generateState(
      callbackURL || currentURL?.origin || c.context.baseURL,
      c.query?.currentURL
    );
    try {
      await c.setSignedCookie(
        cookie.state.name,
        state.code,
        c.context.secret,
        cookie.state.options
      );
      const codeVerifier = generateCodeVerifier();
      await c.setSignedCookie(
        cookie.pkCodeVerifier.name,
        codeVerifier,
        c.context.secret,
        cookie.pkCodeVerifier.options
      );
      const url = provider.createAuthorizationURL({
        state: state.state,
        codeVerifier
      });
      url.searchParams.set(
        "redirect_uri",
        `${c.context.baseURL}/callback/${c.body.provider}`
      );
      return {
        url: url.toString(),
        state: state.state,
        codeVerifier,
        redirect: true
      };
    } catch (e) {
      throw new APIError2("INTERNAL_SERVER_ERROR");
    }
  }
);
var signInEmail = createAuthEndpoint(
  "/sign-in/email",
  {
    method: "POST",
    body: z3.object({
      email: z3.string().email(),
      password: z3.string(),
      callbackURL: z3.string().optional(),
      /**
       * If this is true the session will only be valid for the current browser session
       * @default false
       */
      dontRememberMe: z3.boolean().default(false).optional()
    })
  },
  async (ctx) => {
    if (!ctx.context.options?.emailAndPassword?.enabled) {
      ctx.context.logger.error(
        "Email and password is not enabled. Make sure to enable it in the options on you `auth.ts` file. Check `https://better-auth.com/docs/authentication/email-password` for more!"
      );
      throw new APIError2("BAD_REQUEST", {
        message: "Email and password is not enabled"
      });
    }
    const currentSession = await getSessionFromCtx(ctx);
    if (currentSession) {
      await ctx.context.internalAdapter.deleteSession(
        currentSession.session.id
      );
    }
    const { email, password } = ctx.body;
    const checkEmail = z3.string().email().safeParse(email);
    if (!checkEmail.success) {
      throw new APIError2("BAD_REQUEST", {
        message: "Invalid email"
      });
    }
    const user = await ctx.context.internalAdapter.findUserByEmail(email);
    if (!user) {
      await ctx.context.password.hash(password);
      ctx.context.logger.error("User not found", { email });
      throw new APIError2("UNAUTHORIZED", {
        message: "Invalid email or password"
      });
    }
    const credentialAccount = user.accounts.find(
      (a) => a.providerId === "credential"
    );
    if (!credentialAccount) {
      ctx.context.logger.error("Credential account not found", { email });
      throw new APIError2("UNAUTHORIZED", {
        message: "Invalid email or password"
      });
    }
    const currentPassword = credentialAccount?.password;
    if (!currentPassword) {
      ctx.context.logger.error("Password not found", { email });
      throw new APIError2("UNAUTHORIZED", {
        message: "Unexpected error"
      });
    }
    const validPassword = await ctx.context.password.verify(
      currentPassword,
      password
    );
    if (!validPassword) {
      ctx.context.logger.error("Invalid password");
      throw new APIError2("UNAUTHORIZED", {
        message: "Invalid email or password"
      });
    }
    const session = await ctx.context.internalAdapter.createSession(
      user.user.id,
      ctx.headers,
      ctx.body.dontRememberMe
    );
    if (!session) {
      ctx.context.logger.error("Failed to create session");
      throw new APIError2("INTERNAL_SERVER_ERROR");
    }
    await setSessionCookie(ctx, session.id, ctx.body.dontRememberMe);
    return ctx.json({
      user: user.user,
      session,
      redirect: !!ctx.body.callbackURL,
      url: ctx.body.callbackURL
    });
  }
);

// src/api/routes/callback.ts
import { APIError as APIError3 } from "better-call";
import { z as z5 } from "zod";

// src/db/schema.ts
import { z as z4 } from "zod";
var accountSchema = z4.object({
  id: z4.string(),
  providerId: z4.string(),
  accountId: z4.string(),
  userId: z4.string(),
  accessToken: z4.string().nullable().optional(),
  refreshToken: z4.string().nullable().optional(),
  idToken: z4.string().nullable().optional(),
  /**
   * Access token expires at
   */
  expiresAt: z4.date().nullable().optional(),
  /**
   * Password is only stored in the credential provider
   */
  password: z4.string().optional().nullable()
});
var userSchema = z4.object({
  id: z4.string(),
  email: z4.string().transform((val) => val.toLowerCase()),
  emailVerified: z4.boolean().default(false),
  name: z4.string(),
  image: z4.string().optional(),
  createdAt: z4.date().default(/* @__PURE__ */ new Date()),
  updatedAt: z4.date().default(/* @__PURE__ */ new Date())
});
var sessionSchema = z4.object({
  id: z4.string(),
  userId: z4.string(),
  expiresAt: z4.date(),
  ipAddress: z4.string().optional(),
  userAgent: z4.string().optional()
});
var verificationSchema = z4.object({
  id: z4.string(),
  value: z4.string(),
  expiresAt: z4.date(),
  identifier: z4.string()
});

// src/utils/id.ts
import { nanoid } from "nanoid";
var generateId = (size) => {
  return nanoid(size);
};

// src/utils/hide-metadata.ts
var HIDE_METADATA = {
  isAction: false
};

// src/utils/getAccount.ts
function getAccountTokens(tokens) {
  const accessToken = tokens.accessToken();
  let refreshToken = tokens.hasRefreshToken() ? tokens.refreshToken() : void 0;
  let accessTokenExpiresAt = void 0;
  try {
    accessTokenExpiresAt = tokens.accessTokenExpiresAt();
  } catch {
  }
  return {
    accessToken,
    refreshToken,
    expiresAt: accessTokenExpiresAt
  };
}

// src/api/routes/callback.ts
var callbackOAuth = createAuthEndpoint(
  "/callback/:id",
  {
    method: "GET",
    query: z5.object({
      state: z5.string(),
      code: z5.string().optional(),
      error: z5.string().optional()
    }),
    metadata: HIDE_METADATA
  },
  async (c) => {
    if (c.query.error || !c.query.code) {
      const parsedState2 = parseState(c.query.state);
      const callbackURL2 = parsedState2.data?.callbackURL || `${c.context.baseURL}/error`;
      c.context.logger.error(c.query.error, c.params.id);
      throw c.redirect(
        `${callbackURL2}?error=${c.query.error || "oAuth_code_missing"}`
      );
    }
    const provider = c.context.socialProviders.find(
      (p) => p.id === c.params.id
    );
    if (!provider) {
      c.context.logger.error(
        "Oauth provider with id",
        c.params.id,
        "not found"
      );
      throw c.redirect(
        `${c.context.baseURL}/error?error=oauth_provider_not_found`
      );
    }
    const codeVerifier = await c.getSignedCookie(
      c.context.authCookies.pkCodeVerifier.name,
      c.context.secret
    );
    let tokens;
    try {
      tokens = await provider.validateAuthorizationCode(
        c.query.code,
        codeVerifier,
        `${c.context.baseURL}/callback/${provider.id}`
      );
    } catch (e) {
      c.context.logger.error(e);
      throw c.redirect(
        `${c.context.baseURL}/error?error=oauth_code_verification_failed`
      );
    }
    const user = await provider.getUserInfo(tokens).then((res) => res?.user);
    const id = generateId();
    const data = userSchema.safeParse({
      ...user,
      id
    });
    const parsedState = parseState(c.query.state);
    if (!parsedState.success) {
      c.context.logger.error("Unable to parse state");
      throw c.redirect(
        `${c.context.baseURL}/error?error=invalid_state_parameter`
      );
    }
    const { callbackURL, currentURL, dontRememberMe } = parsedState.data;
    if (!user || data.success === false) {
      throw c.redirect(
        `${c.context.baseURL}/error?error=oauth_validation_failed`
      );
    }
    if (!callbackURL) {
      throw c.redirect(
        `${c.context.baseURL}/error?error=oauth_callback_url_not_found`
      );
    }
    const dbUser = await c.context.internalAdapter.findUserByEmail(user.email).catch((e) => {
      logger.error(
        "Better auth was unable to query your database.\nError: ",
        e
      );
      throw c.redirect(
        `${c.context.baseURL}/error?error=internal_server_error`
      );
    });
    const userId = dbUser?.user.id;
    if (dbUser) {
      const hasBeenLinked = dbUser.accounts.find(
        (a) => a.providerId === provider.id
      );
      const trustedProviders = c.context.options.account?.accountLinking?.trustedProviders;
      const isTrustedProvider = trustedProviders ? trustedProviders.includes(provider.id) : true;
      if (!hasBeenLinked && (!user.emailVerified || !isTrustedProvider)) {
        let url;
        try {
          url = new URL(currentURL || callbackURL);
          url.searchParams.set("error", "account_not_linked");
        } catch (e) {
          throw c.redirect(
            `${c.context.baseURL}/error?error=account_not_linked`
          );
        }
        throw c.redirect(url.toString());
      }
      if (!hasBeenLinked) {
        try {
          await c.context.internalAdapter.linkAccount({
            providerId: provider.id,
            accountId: user.id.toString(),
            id: `${provider.id}:${user.id}`,
            userId: dbUser.user.id,
            ...getAccountTokens(tokens)
          });
        } catch (e) {
          console.log(e);
          throw c.redirect(
            `${c.context.baseURL}/error?error=failed_linking_account`
          );
        }
      }
    } else {
      try {
        await c.context.internalAdapter.createOAuthUser(data.data, {
          ...getAccountTokens(tokens),
          id: `${provider.id}:${user.id}`,
          providerId: provider.id,
          accountId: user.id.toString(),
          userId: id
        });
      } catch (e) {
        const url = new URL(currentURL || callbackURL);
        url.searchParams.set("error", "unable_to_create_user");
        c.setHeader("Location", url.toString());
        throw c.redirect(url.toString());
      }
    }
    if (!userId && !id)
      throw new APIError3("INTERNAL_SERVER_ERROR", {
        message: "Unable to create user"
      });
    try {
      const session = await c.context.internalAdapter.createSession(
        userId || id,
        c.request,
        dontRememberMe
      );
      if (!session) {
        const url = new URL(currentURL || callbackURL);
        url.searchParams.set("error", "unable_to_create_session");
        throw c.redirect(url.toString());
      }
      try {
        await setSessionCookie(c, session.id, dontRememberMe);
      } catch (e) {
        c.context.logger.error("Unable to set session cookie", e);
        const url = new URL(currentURL || callbackURL);
        url.searchParams.set("error", "unable_to_create_session");
        throw c.redirect(url.toString());
      }
    } catch {
      const url = new URL(currentURL || callbackURL);
      url.searchParams.set("error", "unable_to_create_session");
      throw c.redirect(url.toString());
    }
    throw c.redirect(callbackURL);
  }
);

// src/api/routes/sign-out.ts
import { z as z6 } from "zod";
var signOut = createAuthEndpoint(
  "/sign-out",
  {
    method: "POST",
    body: z6.optional(
      z6.object({
        callbackURL: z6.string().optional()
      })
    )
  },
  async (ctx) => {
    const sessionCookieToken = await ctx.getSignedCookie(
      ctx.context.authCookies.sessionToken.name,
      ctx.context.secret
    );
    if (!sessionCookieToken) {
      return ctx.json(null);
    }
    await ctx.context.internalAdapter.deleteSession(sessionCookieToken);
    deleteSessionCookie(ctx);
    return ctx.json(null, {
      body: {
        redirect: !!ctx.body?.callbackURL,
        url: ctx.body?.callbackURL
      }
    });
  }
);

// src/api/routes/forget-password.ts
import { TimeSpan as TimeSpan2 } from "oslo";
import { createJWT, parseJWT as parseJWT3 } from "oslo/jwt";
import { validateJWT } from "oslo/jwt";
import { z as z7 } from "zod";
var forgetPassword = createAuthEndpoint(
  "/forget-password",
  {
    method: "POST",
    body: z7.object({
      /**
       * The email address of the user to send a password reset email to.
       */
      email: z7.string().email(),
      /**
       * The URL to redirect the user to reset their password.
       * If the token isn't valid or expired, it'll be redirected with a query parameter `?
       * error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?
       * token=VALID_TOKEN
       */
      redirectTo: z7.string()
    })
  },
  async (ctx) => {
    if (!ctx.context.options.emailAndPassword?.sendResetPassword) {
      ctx.context.logger.error(
        "Reset password isn't enabled.Please pass an emailAndPassword.sendResetPasswordToken function to your auth config!"
      );
      return ctx.json(null, {
        status: 400,
        statusText: "RESET_PASSWORD_EMAIL_NOT_SENT",
        body: {
          message: "Reset password isn't enabled"
        }
      });
    }
    const { email } = ctx.body;
    const user = await ctx.context.internalAdapter.findUserByEmail(email);
    if (!user) {
      return ctx.json(
        {
          status: false
        },
        {
          body: {
            status: true
          }
        }
      );
    }
    const token = await createJWT(
      "HS256",
      Buffer.from(ctx.context.secret),
      {
        email: user.user.email,
        redirectTo: ctx.body.redirectTo
      },
      {
        expiresIn: new TimeSpan2(1, "h"),
        issuer: "better-auth",
        subject: "forget-password",
        audiences: [user.user.email],
        includeIssuedTimestamp: true
      }
    );
    const url = `${ctx.context.baseURL}/reset-password/${token}`;
    await ctx.context.options.emailAndPassword.sendResetPassword(
      url,
      user.user
    );
    return ctx.json({
      status: true
    });
  }
);
var forgetPasswordCallback = createAuthEndpoint(
  "/reset-password/:token",
  {
    method: "GET"
  },
  async (ctx) => {
    const { token } = ctx.params;
    let decodedToken;
    const schema = z7.object({
      email: z7.string(),
      redirectTo: z7.string()
    });
    try {
      decodedToken = await validateJWT(
        "HS256",
        Buffer.from(ctx.context.secret),
        token
      );
      if (!decodedToken.expiresAt || decodedToken.expiresAt < /* @__PURE__ */ new Date()) {
        throw Error("Token expired");
      }
    } catch (e) {
      const decoded = parseJWT3(token);
      const jwt = schema.safeParse(decoded?.payload);
      if (jwt.success) {
        throw ctx.redirect(`${jwt.data?.redirectTo}?error=invalid_token`);
      } else {
        throw ctx.redirect(`${ctx.context.baseURL}/error?error=invalid_token`);
      }
    }
    const { redirectTo } = schema.parse(decodedToken.payload);
    throw ctx.redirect(`${redirectTo}?token=${token}`);
  }
);
var resetPassword = createAuthEndpoint(
  "/reset-password",
  {
    method: "POST",
    query: z7.object({
      currentURL: z7.string()
    }).optional(),
    body: z7.object({
      newPassword: z7.string(),
      callbackURL: z7.string().optional()
    })
  },
  async (ctx) => {
    const token = ctx.query?.currentURL.split("?token=")[1];
    if (!token) {
      return ctx.json(
        {
          error: "Invalid token",
          data: null
        },
        {
          status: 400,
          statusText: "INVALID_TOKEN",
          body: {
            message: "Invalid token"
          }
        }
      );
    }
    const { newPassword } = ctx.body;
    try {
      const jwt = await validateJWT(
        "HS256",
        Buffer.from(ctx.context.secret),
        token
      );
      const email = z7.string().email().parse(jwt.payload.email);
      const user = await ctx.context.internalAdapter.findUserByEmail(email);
      if (!user) {
        return ctx.json(
          {
            error: "User not found",
            data: null
          },
          {
            status: 400,
            body: {
              message: "failed to reset password"
            }
          }
        );
      }
      if (newPassword.length < (ctx.context.options.emailAndPassword?.minPasswordLength || 8) || newPassword.length > (ctx.context.options.emailAndPassword?.maxPasswordLength || 32)) {
        return ctx.json(
          {
            data: null,
            error: "password is too short or too long"
          },
          {
            status: 400,
            statusText: "INVALID_PASSWORD_LENGTH",
            body: {
              message: "password is too short or too long"
            }
          }
        );
      }
      const hashedPassword = await ctx.context.password.hash(newPassword);
      const updatedUser = await ctx.context.internalAdapter.updatePassword(
        user.user.id,
        hashedPassword
      );
      if (!updatedUser) {
        return ctx.json(null, {
          status: 400,
          statusText: "USER_NOT_FOUND",
          body: {
            message: "User doesn't have a credential account"
          }
        });
      }
      return ctx.json(
        {
          error: null,
          data: {
            status: true,
            url: ctx.body.callbackURL,
            redirect: !!ctx.body.callbackURL
          }
        },
        {
          body: {
            status: true,
            url: ctx.body.callbackURL,
            redirect: !!ctx.body.callbackURL
          }
        }
      );
    } catch (e) {
      console.log(e);
      return ctx.json(
        {
          error: "Invalid token",
          data: null
        },
        {
          status: 400,
          statusText: "INVALID_TOKEN",
          body: {
            message: "Invalid token"
          }
        }
      );
    }
  }
);

// src/api/routes/verify-email.ts
import { TimeSpan as TimeSpan3 } from "oslo";
import { createJWT as createJWT2, validateJWT as validateJWT2 } from "oslo/jwt";
import { z as z8 } from "zod";
async function createEmailVerificationToken(secret, email) {
  const token = await createJWT2(
    "HS256",
    Buffer.from(secret),
    {
      email: email.toLowerCase()
    },
    {
      expiresIn: new TimeSpan3(1, "h"),
      issuer: "better-auth",
      subject: "verify-email",
      audiences: [email],
      includeIssuedTimestamp: true
    }
  );
  return token;
}
var sendVerificationEmail = createAuthEndpoint(
  "/send-verification-email",
  {
    method: "POST",
    query: z8.object({
      currentURL: z8.string().optional()
    }).optional(),
    body: z8.object({
      email: z8.string().email(),
      callbackURL: z8.string().optional()
    })
  },
  async (ctx) => {
    if (!ctx.context.options.emailAndPassword?.sendVerificationEmail) {
      ctx.context.logger.error(
        "Verification email isn't enabled. Pass `sendVerificationEmail` in `emailAndPassword` options to enable it."
      );
      return ctx.json(null, {
        status: 400,
        statusText: "VERIFICATION_EMAIL_NOT_SENT",
        body: {
          message: "Verification email isn't enabled"
        }
      });
    }
    const { email } = ctx.body;
    const token = await createEmailVerificationToken(ctx.context.secret, email);
    const url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || ctx.query?.currentURL || "/"}`;
    await ctx.context.options.emailAndPassword.sendVerificationEmail(
      email,
      url,
      token
    );
    return ctx.json({
      status: true
    });
  }
);
var verifyEmail = createAuthEndpoint(
  "/verify-email",
  {
    method: "GET",
    query: z8.object({
      token: z8.string(),
      callbackURL: z8.string().optional()
    })
  },
  async (ctx) => {
    const { token } = ctx.query;
    let jwt;
    try {
      jwt = await validateJWT2("HS256", Buffer.from(ctx.context.secret), token);
    } catch (e) {
      ctx.context.logger.error("Failed to verify email", e);
      return ctx.json(null, {
        status: 400,
        statusText: "INVALID_TOKEN",
        body: {
          message: "Invalid token"
        }
      });
    }
    const schema = z8.object({
      email: z8.string().email()
    });
    const parsed = schema.parse(jwt.payload);
    const user = await ctx.context.internalAdapter.findUserByEmail(
      parsed.email
    );
    if (!user) {
      return ctx.json(null, {
        status: 400,
        statusText: "USER_NOT_FOUND",
        body: {
          message: "User not found"
        }
      });
    }
    const account = user.accounts.find((a) => a.providerId === "credential");
    if (!account) {
      throw ctx.redirect;
    }
    await ctx.context.internalAdapter.updateUserByEmail(parsed.email, {
      emailVerified: true
    });
    if (ctx.query.callbackURL) {
      console.log("Redirecting to", ctx.query.callbackURL);
      throw ctx.redirect("/");
    }
    return ctx.json({
      status: true
    });
  }
);

// src/api/routes/update-user.ts
import { z as z9 } from "zod";

// src/crypto/random.ts
function byteToBinary(byte) {
  return byte.toString(2).padStart(8, "0");
}
function bytesToBinary(bytes) {
  return [...bytes].map((val) => byteToBinary(val)).join("");
}
function bytesToInteger(bytes) {
  return parseInt(bytesToBinary(bytes), 2);
}
function generateRandomInteger(max) {
  if (max < 0 || !Number.isInteger(max)) {
    throw new Error(
      "Argument 'max' must be an integer greater than or equal to 0"
    );
  }
  const bitLength = (max - 1).toString(2).length;
  const shift = bitLength % 8;
  const bytes = new Uint8Array(Math.ceil(bitLength / 8));
  crypto.getRandomValues(bytes);
  if (shift !== 0) {
    bytes[0] &= (1 << shift) - 1;
  }
  let result = bytesToInteger(bytes);
  while (result >= max) {
    crypto.getRandomValues(bytes);
    if (shift !== 0) {
      bytes[0] &= (1 << shift) - 1;
    }
    result = bytesToInteger(bytes);
  }
  return result;
}
function generateRandomString(length, alphabet2) {
  let result = "";
  for (let i = 0; i < length; i++) {
    result += alphabet2[generateRandomInteger(alphabet2.length)];
  }
  return result;
}
function alphabet(...patterns) {
  const patternSet = new Set(patterns);
  let result = "";
  for (const pattern of patternSet) {
    if (pattern === "a-z") {
      result += "abcdefghijklmnopqrstuvwxyz";
    } else if (pattern === "A-Z") {
      result += "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    } else if (pattern === "0-9") {
      result += "0123456789";
    } else {
      result += pattern;
    }
  }
  return result;
}

// src/api/routes/update-user.ts
var updateUser = createAuthEndpoint(
  "/user/update",
  {
    method: "POST",
    body: z9.object({
      name: z9.string().optional(),
      image: z9.string().optional()
    }),
    use: [sessionMiddleware]
  },
  async (ctx) => {
    const { name, image } = ctx.body;
    const session = ctx.context.session;
    if (!image && !name) {
      return ctx.json(session.user);
    }
    const user = await ctx.context.internalAdapter.updateUserByEmail(
      session.user.email,
      {
        name,
        image
      }
    );
    return ctx.json(user);
  }
);
var changePassword = createAuthEndpoint(
  "/user/change-password",
  {
    method: "POST",
    body: z9.object({
      /**
       * The new password to set
       */
      newPassword: z9.string(),
      /**
       * The current password of the user
       */
      currentPassword: z9.string(),
      /**
       * revoke all sessions that are not the
       * current one logged in by the user
       */
      revokeOtherSessions: z9.boolean().optional()
    }),
    use: [sessionMiddleware]
  },
  async (ctx) => {
    const { newPassword, currentPassword, revokeOtherSessions } = ctx.body;
    const session = ctx.context.session;
    const minPasswordLength = ctx.context.password.config.minPasswordLength;
    if (newPassword.length < minPasswordLength) {
      ctx.context.logger.error("Password is too short");
      return ctx.json(null, {
        status: 400,
        body: { message: "Password is too short" }
      });
    }
    const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
    if (newPassword.length > maxPasswordLength) {
      ctx.context.logger.error("Password is too long");
      return ctx.json(null, {
        status: 400,
        body: { message: "Password is too long" }
      });
    }
    const accounts = await ctx.context.internalAdapter.findAccounts(
      session.user.id
    );
    const account = accounts.find(
      (account2) => account2.providerId === "credential" && account2.password
    );
    if (!account || !account.password) {
      return ctx.json(null, {
        status: 400,
        body: { message: "User does not have a password" }
      });
    }
    const passwordHash = await ctx.context.password.hash(newPassword);
    const verify = await ctx.context.password.verify(
      account.password,
      currentPassword
    );
    if (!verify) {
      return ctx.json(null, {
        status: 400,
        body: { message: "Invalid password" }
      });
    }
    await ctx.context.internalAdapter.updateAccount(account.id, {
      password: passwordHash
    });
    if (revokeOtherSessions) {
      await ctx.context.internalAdapter.deleteSessions(session.user.id);
      const newSession = await ctx.context.internalAdapter.createSession(
        session.user.id,
        ctx.headers
      );
      if (!newSession) {
        return ctx.json(null, {
          status: 500,
          body: { message: "Failed to create session" }
        });
      }
      await setSessionCookie(ctx, newSession.id);
    }
    return ctx.json(session.user);
  }
);
var setPassword = createAuthEndpoint(
  "/user/set-password",
  {
    method: "POST",
    body: z9.object({
      /**
       * The new password to set
       */
      newPassword: z9.string()
    }),
    use: [sessionMiddleware]
  },
  async (ctx) => {
    const { newPassword } = ctx.body;
    const session = ctx.context.session;
    const minPasswordLength = ctx.context.password.config.minPasswordLength;
    if (newPassword.length < minPasswordLength) {
      ctx.context.logger.error("Password is too short");
      return ctx.json(null, {
        status: 400,
        body: { message: "Password is too short" }
      });
    }
    const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
    if (newPassword.length > maxPasswordLength) {
      ctx.context.logger.error("Password is too long");
      return ctx.json(null, {
        status: 400,
        body: { message: "Password is too long" }
      });
    }
    const accounts = await ctx.context.internalAdapter.findAccounts(
      session.user.id
    );
    const account = accounts.find(
      (account2) => account2.providerId === "credential" && account2.password
    );
    const passwordHash = await ctx.context.password.hash(newPassword);
    if (!account) {
      await ctx.context.internalAdapter.linkAccount({
        id: generateRandomString(32, alphabet("a-z", "0-9", "A-Z")),
        userId: session.user.id,
        providerId: "credential",
        accountId: session.user.id,
        password: passwordHash
      });
      return ctx.json(session.user);
    }
    return ctx.json(null, {
      status: 400,
      body: { message: "User already has a password" }
    });
  }
);
var deleteUser = createAuthEndpoint(
  "/user/delete",
  {
    method: "POST",
    body: z9.object({
      password: z9.string()
    }),
    use: [sessionMiddleware]
  },
  async (ctx) => {
    const { password } = ctx.body;
    const session = ctx.context.session;
    const accounts = await ctx.context.internalAdapter.findAccounts(
      session.user.id
    );
    const account = accounts.find(
      (account2) => account2.providerId === "credential" && account2.password
    );
    if (!account || !account.password) {
      return ctx.json(null, {
        status: 400,
        body: { message: "User does not have a password" }
      });
    }
    const verify = await ctx.context.password.verify(
      account.password,
      password
    );
    if (!verify) {
      return ctx.json(null, {
        status: 400,
        body: { message: "Invalid password" }
      });
    }
    await ctx.context.internalAdapter.deleteUser(session.user.id);
    await ctx.context.internalAdapter.deleteSessions(session.user.id);
    return ctx.json(null);
  }
);

// src/crypto/index.ts
import { xchacha20poly1305 } from "@noble/ciphers/chacha";
import { bytesToHex, hexToBytes, utf8ToBytes } from "@noble/ciphers/utils";
import { managedNonce } from "@noble/ciphers/webcrypto";
import { sha256 } from "@noble/hashes/sha256";
async function hs256(secretKey, message) {
  const enc = new TextEncoder();
  const algorithm = { name: "HMAC", hash: "SHA-256" };
  const key = await crypto.subtle.importKey(
    "raw",
    enc.encode(secretKey),
    algorithm,
    false,
    ["sign", "verify"]
  );
  const signature = await crypto.subtle.sign(
    algorithm.name,
    key,
    enc.encode(message)
  );
  return btoa(String.fromCharCode(...new Uint8Array(signature)));
}
var symmetricEncrypt = ({ key, data }) => {
  const keyAsBytes = sha256(key);
  const dataAsBytes = utf8ToBytes(data);
  const chacha = managedNonce(xchacha20poly1305)(keyAsBytes);
  return bytesToHex(chacha.encrypt(dataAsBytes));
};
var symmetricDecrypt = ({ key, data }) => {
  const keyAsBytes = sha256(key);
  const dataAsBytes = hexToBytes(data);
  const chacha = managedNonce(xchacha20poly1305)(keyAsBytes);
  return chacha.decrypt(dataAsBytes);
};

// src/api/routes/csrf.ts
var getCSRFToken = createAuthEndpoint(
  "/csrf",
  {
    method: "GET",
    metadata: HIDE_METADATA
  },
  async (ctx) => {
    const csrfToken = await ctx.getSignedCookie(
      ctx.context.authCookies.csrfToken.name,
      ctx.context.secret
    );
    if (csrfToken) {
      return {
        csrfToken
      };
    }
    const token = generateRandomString(32, alphabet("a-z", "0-9", "A-Z"));
    const hash = await hs256(ctx.context.secret, token);
    const cookie = `${token}!${hash}`;
    await ctx.setSignedCookie(
      ctx.context.authCookies.csrfToken.name,
      cookie,
      ctx.context.secret,
      ctx.context.authCookies.csrfToken.options
    );
    return {
      csrfToken: token
    };
  }
);

// src/api/routes/error.ts
var html = (errorCode = "Unknown") => `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Authentication Error</title>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --text-color: #212529;
            --accent-color: #000000;
            --error-color: #dc3545;
            --border-color: #e9ecef;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            line-height: 1.5;
        }
        .error-container {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            padding: 2.5rem;
            text-align: center;
            max-width: 90%;
            width: 400px;
        }
        h1 {
            color: var(--error-color);
            font-size: 1.75rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }
        p {
            margin-bottom: 1.5rem;
            color: #495057;
        }
        .btn {
            background-color: var(--accent-color);
            color: #ffffff;
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            transition: all 0.3s ease;
            display: inline-block;
            font-weight: 500;
            border: 2px solid var(--accent-color);
        }
        .btn:hover {
            background-color: #131721;
        }
        .error-code {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }
        .icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="error-container">
        <div class="icon">\u26A0\uFE0F</div>
        <h1>Better Auth Error</h1>
        <p>We encountered an issue while processing your request. Please try again or contact the application owner if the problem persists.</p>
        <a href="/" id="returnLink" class="btn">Return to Application</a>
        <div class="error-code">Error Code: <span id="errorCode">${errorCode}</span></div>
    </div>
</body>
</html>`;
var error = createAuthEndpoint(
  "/error",
  {
    method: "GET",
    metadata: HIDE_METADATA
  },
  async (c) => {
    const query = new URL(c.request?.url || "").searchParams.get("error") || "Unknown";
    return new Response(html(query), {
      headers: {
        "Content-Type": "text/html"
      }
    });
  }
);

// src/api/routes/ok.ts
var ok = createAuthEndpoint(
  "/ok",
  {
    method: "GET",
    metadata: HIDE_METADATA
  },
  async (ctx) => {
    return ctx.json({
      ok: true
    });
  }
);

// src/api/routes/sign-up.ts
import { z as z10 } from "zod";
var signUpEmail = createAuthEndpoint(
  "/sign-up/email",
  {
    method: "POST",
    query: z10.object({
      currentURL: z10.string().optional()
    }).optional(),
    body: z10.object({
      name: z10.string(),
      email: z10.string(),
      password: z10.string(),
      image: z10.string().optional(),
      callbackURL: z10.string().optional()
    })
  },
  async (ctx) => {
    if (!ctx.context.options.emailAndPassword?.enabled) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Email and password is not enabled"
        }
      });
    }
    const { name, email, password, image } = ctx.body;
    const isValidEmail = z10.string().email().safeParse(email);
    if (!isValidEmail.success) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Invalid email address"
        }
      });
    }
    const minPasswordLength = ctx.context.password.config.minPasswordLength;
    if (password.length < minPasswordLength) {
      ctx.context.logger.error("Password is too short");
      return ctx.json(null, {
        status: 400,
        body: { message: "Password is too short" }
      });
    }
    const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
    if (password.length > maxPasswordLength) {
      ctx.context.logger.error("Password is too long");
      return ctx.json(null, {
        status: 400,
        body: { message: "Password is too long" }
      });
    }
    const dbUser = await ctx.context.internalAdapter.findUserByEmail(email);
    const hash = await ctx.context.password.hash(password);
    if (dbUser?.user) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "User already exists"
        }
      });
    }
    const createdUser = await ctx.context.internalAdapter.createUser({
      id: generateRandomString(32, alphabet("a-z", "0-9", "A-Z")),
      email: email.toLowerCase(),
      name,
      image,
      emailVerified: false,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    });
    if (!createdUser) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Could not create user"
        }
      });
    }
    await ctx.context.internalAdapter.linkAccount({
      id: generateRandomString(32, alphabet("a-z", "0-9", "A-Z")),
      userId: createdUser.id,
      providerId: "credential",
      accountId: createdUser.id,
      password: hash
    });
    const session = await ctx.context.internalAdapter.createSession(
      createdUser.id,
      ctx.request
    );
    if (!session) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Could not create session"
        }
      });
    }
    await setSessionCookie(ctx, session.id);
    if (ctx.context.options.emailAndPassword.sendEmailVerificationOnSignUp) {
      const token = await createEmailVerificationToken(
        ctx.context.secret,
        createdUser.email
      );
      const url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || ctx.query?.currentURL || "/"}`;
      await ctx.context.options.emailAndPassword.sendVerificationEmail?.(
        createdUser.email,
        url,
        token
      );
    }
    return ctx.json(
      {
        user: createdUser,
        session
      },
      {
        body: ctx.body.callbackURL ? {
          url: ctx.body.callbackURL,
          redirect: true
        } : {
          user: createdUser,
          session
        }
      }
    );
  }
);

// src/utils/shim.ts
var shimContext = (originalObject, newContext) => {
  const shimmedObj = {};
  for (const [key, value] of Object.entries(originalObject)) {
    shimmedObj[key] = (ctx) => {
      return value({
        ...ctx,
        context: {
          ...newContext,
          ...ctx.context
        }
      });
    };
    shimmedObj[key].path = value.path;
    shimmedObj[key].method = value.method;
    shimmedObj[key].options = value.options;
    shimmedObj[key].headers = value.headers;
  }
  return shimmedObj;
};

// src/plugins/organization/access/index.ts
var access_exports = {};
__export(access_exports, {
  AccessControl: () => AccessControl,
  ParsingError: () => ParsingError,
  Role: () => Role,
  adminAc: () => adminAc,
  createAccessControl: () => createAccessControl,
  defaultAc: () => defaultAc,
  defaultRoles: () => defaultRoles,
  defaultStatements: () => defaultStatements,
  memberAc: () => memberAc,
  ownerAc: () => ownerAc,
  permissionFromString: () => permissionFromString
});

// src/plugins/organization/access/src/access.ts
var ParsingError = class extends Error {
  path;
  constructor(message, path) {
    super(message);
    this.path = path;
  }
};
var AccessControl = class {
  constructor(s) {
    this.s = s;
    this.statements = s;
  }
  statements;
  newRole(statements) {
    return new Role(statements);
  }
};
var Role = class _Role {
  statements;
  constructor(statements) {
    this.statements = statements;
  }
  authorize(request, connector) {
    for (const [requestedResource, requestedActions] of Object.entries(
      request
    )) {
      const allowedActions = this.statements[requestedResource];
      if (!allowedActions) {
        return {
          success: false,
          error: `You are not allowed to access resource: ${requestedResource}`
        };
      }
      const success = connector === "OR" ? requestedActions.some(
        (requestedAction) => allowedActions.includes(requestedAction)
      ) : requestedActions.every(
        (requestedAction) => allowedActions.includes(requestedAction)
      );
      if (success) {
        return { success };
      }
      return {
        success: false,
        error: `unauthorized to access resource "${requestedResource}"`
      };
    }
    return {
      success: false,
      error: "Not authorized"
    };
  }
  static fromString(s) {
    const statements = JSON.parse(s);
    if (typeof statements !== "object") {
      throw new ParsingError("statements is not an object", ".");
    }
    for (const [resource, actions] of Object.entries(statements)) {
      if (typeof resource !== "string") {
        throw new ParsingError("invalid resource identifier", resource);
      }
      if (!Array.isArray(actions)) {
        throw new ParsingError("actions is not an array", resource);
      }
      for (let i = 0; i < actions.length; i++) {
        if (typeof actions[i] !== "string") {
          throw new ParsingError("action is not a string", `${resource}[${i}]`);
        }
      }
    }
    return new _Role(statements);
  }
  toString() {
    return JSON.stringify(this.statements);
  }
};

// src/plugins/organization/access/statement.ts
var createAccessControl = (statements) => {
  return new AccessControl(statements);
};
var defaultStatements = {
  organization: ["update", "delete"],
  member: ["create", "update", "delete"],
  invitation: ["create", "cancel"]
};
var defaultAc = createAccessControl(defaultStatements);
var adminAc = defaultAc.newRole({
  organization: ["update"],
  invitation: ["create", "cancel"],
  member: ["create", "update", "delete"]
});
var ownerAc = defaultAc.newRole({
  organization: ["update", "delete"],
  member: ["create", "update", "delete"],
  invitation: ["create", "cancel"]
});
var memberAc = defaultAc.newRole({
  organization: [],
  member: [],
  invitation: []
});
var defaultRoles = {
  admin: adminAc,
  owner: ownerAc,
  member: memberAc
};

// src/plugins/organization/access/utils.ts
var permissionFromString = (permission) => {
  return Role.fromString(permission ?? "");
};

// src/plugins/organization/adapter.ts
var directDBCalls = {
  findFullOrganization: async (orgId, db) => {
    const rows = await db?.selectFrom("organization").leftJoin("member", "organization.id", "member.organizationId").leftJoin("invitation", "organization.id", "invitation.organizationId").leftJoin("user", "member.userId", "user.id").where("organization.id", "=", orgId).select([
      "organization.id as org_id",
      "organization.name as org_name",
      "organization.slug as org_slug",
      "organization.logo as org_logo",
      "organization.metadata as org_metadata",
      "organization.createdAt as org_createdAt",
      "member.id as member_id",
      "member.userId as member_user_id",
      "member.role as member_role",
      "member.createdAt as member_createdAt",
      "invitation.id as invitation_id",
      "invitation.email as invitation_email",
      "invitation.status as invitation_status",
      "invitation.expiresAt as invitation_expiresAt",
      "invitation.role as invitation_role",
      "invitation.inviterId as invitation_inviterId",
      "user.id as user_id",
      "user.name as user_name",
      "user.email as user_email",
      "user.image as user_image"
    ]).execute();
    if (!rows || rows.length === 0) {
      return null;
    }
    const organization2 = {
      id: rows[0].org_id,
      name: rows[0].org_name,
      slug: rows[0].org_slug,
      logo: rows[0].org_logo,
      metadata: rows[0].org_metadata ? JSON.parse(rows[0].org_metadata) : void 0,
      createdAt: rows[0].org_createdAt,
      members: [],
      invitations: []
    };
    rows.forEach((row) => {
      if (row.member_id) {
        const existingMember = organization2.members.find(
          (m) => m.id === row.member_id
        );
        if (!existingMember) {
          organization2.members.push({
            id: row.member_id,
            userId: row.member_user_id,
            role: row.member_role,
            createdAt: row.member_createdAt,
            // Add other member fields
            user: {
              id: row.user_id,
              name: row.user_name,
              email: row.user_email,
              image: row.user_image
            },
            email: row.user_email,
            organizationId: row.org_id
          });
        }
      }
      if (row.invitation_id) {
        organization2.invitations.push({
          id: row.invitation_id,
          email: row.invitation_email,
          status: row.invitation_status,
          expiresAt: row.invitation_expiresAt,
          organizationId: row.org_id,
          role: row.invitation_role,
          inviterId: row.invitation_inviterId
        });
      }
    });
    return organization2;
  }
};
var getOrgAdapter = (adapter, options) => {
  return {
    findOrganizationBySlug: async (slug) => {
      const organization2 = await adapter.findOne({
        model: "organization",
        where: [
          {
            field: "slug",
            value: slug
          }
        ]
      });
      return organization2;
    },
    createOrganization: async (data) => {
      const organization2 = await adapter.create({
        model: "organization",
        data: {
          ...data.organization,
          metadata: data.organization.metadata ? JSON.stringify(data.organization.metadata) : void 0
        }
      });
      const member = await adapter.create({
        model: "member",
        data: {
          id: generateId(),
          organizationId: organization2.id,
          userId: data.user.id,
          createdAt: /* @__PURE__ */ new Date(),
          email: data.user.email,
          role: options?.creatorRole || "owner"
        }
      });
      return {
        ...organization2,
        metadata: organization2.metadata ? JSON.parse(organization2.metadata) : void 0,
        members: [
          {
            ...member,
            user: {
              id: data.user.id,
              name: data.user.name,
              email: data.user.email,
              image: data.user.image
            }
          }
        ]
      };
    },
    findMemberByEmail: async (data) => {
      const member = await adapter.findOne({
        model: "member",
        where: [
          {
            field: "email",
            value: data.email
          },
          {
            field: "organizationId",
            value: data.organizationId
          }
        ]
      });
      if (!member) {
        return null;
      }
      const user = await adapter.findOne({
        model: "user",
        where: [
          {
            field: "id",
            value: member.userId
          }
        ]
      });
      if (!user) {
        return null;
      }
      return {
        ...member,
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          image: user.image
        }
      };
    },
    findMemberByOrgId: async (data) => {
      const member = await adapter.findOne({
        model: "member",
        where: [
          {
            field: "userId",
            value: data.userId
          },
          {
            field: "organizationId",
            value: data.organizationId
          }
        ]
      });
      if (!member) {
        return null;
      }
      const user = await adapter.findOne({
        model: "user",
        where: [
          {
            field: "id",
            value: member.userId
          }
        ]
      });
      if (!user) {
        return null;
      }
      return {
        ...member,
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          image: user.image
        }
      };
    },
    findMemberById: async (memberId) => {
      const member = await adapter.findOne({
        model: "member",
        where: [
          {
            field: "id",
            value: memberId
          }
        ]
      });
      if (!member) {
        return null;
      }
      const user = await adapter.findOne({
        model: "user",
        where: [
          {
            field: "id",
            value: member.userId
          }
        ]
      });
      if (!user) {
        return null;
      }
      return {
        ...member,
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          image: user.image
        }
      };
    },
    createMember: async (data) => {
      const member = await adapter.create({
        model: "member",
        data
      });
      return member;
    },
    updateMember: async (memberId, role2) => {
      const member = await adapter.update({
        model: "member",
        where: [
          {
            field: "id",
            value: memberId
          }
        ],
        update: {
          role: role2
        }
      });
      return member;
    },
    deleteMember: async (memberId) => {
      const member = await adapter.delete({
        model: "member",
        where: [
          {
            field: "id",
            value: memberId
          }
        ]
      });
      return member;
    },
    updateOrganization: async (orgId, data) => {
      const organization2 = await adapter.update({
        model: "organization",
        where: [
          {
            field: "id",
            value: orgId
          }
        ],
        update: data
      });
      return organization2;
    },
    deleteOrganization: async (orgId) => {
      await adapter.delete({
        model: "member",
        where: [
          {
            field: "organizationId",
            value: orgId
          }
        ]
      });
      await adapter.delete({
        model: "invitation",
        where: [
          {
            field: "organizationId",
            value: orgId
          }
        ]
      });
      await adapter.delete({
        model: "organization",
        where: [
          {
            field: "id",
            value: orgId
          }
        ]
      });
      return orgId;
    },
    setActiveOrganization: async (sessionId, orgId) => {
      const session = await adapter.update({
        model: "session",
        where: [
          {
            field: "id",
            value: sessionId
          }
        ],
        update: {
          activeOrganizationId: orgId
        }
      });
      return session;
    },
    findOrganizationById: async (orgId) => {
      const organization2 = await adapter.findOne({
        model: "organization",
        where: [
          {
            field: "id",
            value: orgId
          }
        ]
      });
      return organization2;
    },
    /**
     * @requires db
     */
    findFullOrganization: async (orgId, db) => {
      async function base() {
        const org = await adapter.findOne({
          model: "organization",
          where: [
            {
              field: "id",
              value: orgId
            }
          ]
        });
        const invitations = await adapter.findMany({
          model: "invitation",
          where: [
            {
              field: "organizationId",
              value: orgId
            }
          ]
        });
        const members = await adapter.findMany({
          model: "member",
          where: [
            {
              field: "organizationId",
              value: orgId
            }
          ]
        });
        const membersWithUsers = await Promise.all(
          members.map(async (member) => {
            const user = await adapter.findOne({
              model: "user",
              where: [
                {
                  field: "id",
                  value: member.userId
                }
              ]
            });
            if (!user) {
              throw new BetterAuthError(
                "Unexpected error: User not found for member"
              );
            }
            return {
              ...member,
              user: {
                id: user.id,
                name: user.name,
                email: user.email,
                image: user.image
              }
            };
          })
        );
        const fullOrg = {
          ...org,
          invitations,
          members: membersWithUsers
        };
        return fullOrg;
      }
      if (db) {
        return directDBCalls.findFullOrganization(orgId, db);
      }
      return base();
    },
    listOrganizations: async (userId) => {
      const members = await adapter.findMany({
        model: "member",
        where: [
          {
            field: "userId",
            value: userId
          }
        ]
      });
      const organizationIds = members?.map((member) => member.organizationId);
      if (!organizationIds) {
        return [];
      }
      const organizations = [];
      for (const id of organizationIds) {
        const organization2 = await adapter.findOne({
          model: "organization",
          where: [
            {
              field: "id",
              value: id
            }
          ]
        });
        if (organization2) {
          organizations.push(organization2);
        }
      }
      return organizations;
    },
    createInvitation: async ({
      invitation,
      user
    }) => {
      const defaultExpiration = 1e3 * 60 * 60 * 48;
      const expiresAt = getDate(
        options?.invitationExpiresIn || defaultExpiration
      );
      const invite = await adapter.create({
        model: "invitation",
        data: {
          id: generateId(),
          email: invitation.email,
          role: invitation.role,
          organizationId: invitation.organizationId,
          status: "pending",
          expiresAt,
          inviterId: user.id
        }
      });
      return invite;
    },
    findInvitationById: async (id) => {
      const invitation = await adapter.findOne({
        model: "invitation",
        where: [
          {
            field: "id",
            value: id
          }
        ]
      });
      return invitation;
    },
    findPendingInvitation: async (data) => {
      const invitation = await adapter.findMany({
        model: "invitation",
        where: [
          {
            field: "email",
            value: data.email
          },
          {
            field: "organizationId",
            value: data.organizationId
          },
          {
            field: "status",
            value: "pending"
          }
        ]
      });
      return invitation.filter(
        (invite) => new Date(invite.expiresAt) > /* @__PURE__ */ new Date()
      );
    },
    updateInvitation: async (data) => {
      const invitation = await adapter.update({
        model: "invitation",
        where: [
          {
            field: "id",
            value: data.invitationId
          }
        ],
        update: {
          status: data.status
        }
      });
      return invitation;
    }
  };
};

// src/plugins/organization/call.ts
import "better-call";

// src/api/index.ts
import {
  APIError as APIError5,
  createRouter
} from "better-call";

// src/api/middlewares/csrf.ts
import { APIError as APIError4 } from "better-call";
import { z as z11 } from "zod";
var csrfMiddleware = createAuthMiddleware(
  {
    body: z11.object({
      csrfToken: z11.string().optional()
    }).optional()
  },
  async (ctx) => {
    if (ctx.request?.method !== "POST" || ctx.context.options.advanced?.disableCSRFCheck) {
      return;
    }
    const url = new URL(ctx.request.url);
    if (url.origin === new URL(ctx.context.baseURL).origin || ctx.context.options.trustedOrigins?.includes(url.origin)) {
      return;
    }
    const csrfToken = ctx.body?.csrfToken;
    const csrfCookie = await ctx.getSignedCookie(
      ctx.context.authCookies.csrfToken.name,
      ctx.context.secret
    );
    const [token, hash] = csrfCookie?.split("!") || [null, null];
    if (!csrfToken || !csrfCookie || !token || !hash || csrfCookie !== csrfToken) {
      ctx.setCookie(ctx.context.authCookies.csrfToken.name, "", {
        maxAge: 0
      });
      throw new APIError4("UNAUTHORIZED", {
        message: "Invalid CSRF Token"
      });
    }
    const expectedHash = await hs256(ctx.context.secret, token);
    if (hash !== expectedHash) {
      ctx.setCookie(ctx.context.authCookies.csrfToken.name, "", {
        maxAge: 0
      });
      throw new APIError4("UNAUTHORIZED", {
        message: "Invalid CSRF Token"
      });
    }
  }
);

// src/api/index.ts
import chalk from "chalk";

// src/plugins/organization/call.ts
var orgMiddleware = createAuthMiddleware(async (ctx) => {
  return {};
});
var orgSessionMiddleware = createAuthMiddleware(
  {
    use: [sessionMiddleware]
  },
  async (ctx) => {
    const session = ctx.context.session;
    return {
      session
    };
  }
);

// src/plugins/organization/routes/crud-invites.ts
import { z as z13 } from "zod";

// src/plugins/organization/schema.ts
import { z as z12 } from "zod";
var role = z12.enum(["admin", "member", "owner"]);
var invitationStatus = z12.enum(["pending", "accepted", "rejected", "canceled"]).default("pending");
var organizationSchema = z12.object({
  id: z12.string(),
  name: z12.string(),
  slug: z12.string(),
  logo: z12.string().optional(),
  metadata: z12.record(z12.string()).or(z12.string().transform((v) => JSON.parse(v))).optional(),
  createdAt: z12.date()
});
var memberSchema = z12.object({
  id: z12.string(),
  email: z12.string(),
  organizationId: z12.string(),
  userId: z12.string(),
  role,
  createdAt: z12.date()
});
var invitationSchema = z12.object({
  id: z12.string(),
  organizationId: z12.string(),
  email: z12.string(),
  role,
  status: invitationStatus,
  /**
   * The id of the user who invited the user.
   */
  inviterId: z12.string(),
  expiresAt: z12.date()
});

// src/plugins/organization/routes/crud-invites.ts
var createInvitation = createAuthEndpoint(
  "/organization/invite-member",
  {
    method: "POST",
    use: [orgMiddleware, orgSessionMiddleware],
    body: z13.object({
      email: z13.string(),
      role,
      organizationId: z13.string().optional(),
      resend: z13.boolean().optional()
    })
  },
  async (ctx) => {
    if (!ctx.context.orgOptions.sendInvitationEmail) {
      logger.warn(
        "Invitation email is not enabled. Pass `sendInvitationEmail` to the plugin options to enable it."
      );
      return ctx.json(null, {
        status: 400,
        body: {
          message: "invitation is not enabled"
        }
      });
    }
    const session = ctx.context.session;
    const orgId = ctx.body.organizationId || session.session.activeOrganizationId;
    if (!orgId) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Organization id not found!"
        }
      });
    }
    const adapter = getOrgAdapter(ctx.context.adapter, ctx.context.orgOptions);
    const member = await adapter.findMemberByOrgId({
      userId: session.user.id,
      organizationId: orgId
    });
    if (!member) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "User is not a member of this organization!"
        }
      });
    }
    const role2 = ctx.context.roles[member.role];
    if (!role2) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Role not found!"
        }
      });
    }
    const canInvite = role2.authorize({
      invitation: ["create"]
    });
    if (canInvite.error) {
      return ctx.json(null, {
        body: {
          message: "You are not allowed to invite users to this organization"
        },
        status: 403
      });
    }
    const alreadyMember = await adapter.findMemberByEmail({
      email: ctx.body.email,
      organizationId: orgId
    });
    if (alreadyMember) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "User is already a member of this organization"
        }
      });
    }
    const alreadyInvited = await adapter.findPendingInvitation({
      email: ctx.body.email,
      organizationId: orgId
    });
    if (alreadyInvited.length && !ctx.body.resend) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "User is already invited to this organization"
        }
      });
    }
    const invitation = await adapter.createInvitation({
      invitation: {
        role: ctx.body.role,
        email: ctx.body.email,
        organizationId: orgId
      },
      user: session.user
    });
    const organization2 = await adapter.findOrganizationById(orgId);
    if (!organization2) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Organization not found!"
        }
      });
    }
    await ctx.context.orgOptions.sendInvitationEmail?.(
      {
        id: invitation.id,
        role: invitation.role,
        email: invitation.email,
        organization: organization2,
        inviter: {
          ...member,
          user: session.user
        }
      },
      ctx.request
    );
    return ctx.json(invitation);
  }
);
var acceptInvitation = createAuthEndpoint(
  "/organization/accept-invitation",
  {
    method: "POST",
    body: z13.object({
      invitationId: z13.string()
    }),
    use: [orgMiddleware, orgSessionMiddleware]
  },
  async (ctx) => {
    const session = ctx.context.session;
    const adapter = getOrgAdapter(ctx.context.adapter, ctx.context.orgOptions);
    const invitation = await adapter.findInvitationById(ctx.body.invitationId);
    if (!invitation || invitation.expiresAt < /* @__PURE__ */ new Date() || invitation.status !== "pending") {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Invitation not found!"
        }
      });
    }
    if (invitation.email !== session.user.email) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "You are not the recipient of the invitation"
        }
      });
    }
    const acceptedI = await adapter.updateInvitation({
      invitationId: ctx.body.invitationId,
      status: "accepted"
    });
    const member = await adapter.createMember({
      id: generateId(),
      organizationId: invitation.organizationId,
      userId: session.user.id,
      email: invitation.email,
      role: invitation.role,
      createdAt: /* @__PURE__ */ new Date()
    });
    await adapter.setActiveOrganization(
      session.session.id,
      invitation.organizationId
    );
    if (!acceptedI) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Invitation not found!"
        }
      });
    }
    return ctx.json({
      invitation: acceptedI,
      member
    });
  }
);
var rejectInvitation = createAuthEndpoint(
  "/organization/reject-invitation",
  {
    method: "POST",
    body: z13.object({
      invitationId: z13.string()
    }),
    use: [orgMiddleware, orgSessionMiddleware]
  },
  async (ctx) => {
    const session = ctx.context.session;
    const adapter = getOrgAdapter(ctx.context.adapter, ctx.context.orgOptions);
    const invitation = await adapter.findInvitationById(ctx.body.invitationId);
    if (!invitation || invitation.expiresAt < /* @__PURE__ */ new Date() || invitation.status !== "pending") {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Invitation not found!"
        }
      });
    }
    if (invitation.email !== session.user.email) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "You are not the recipient of the invitation"
        }
      });
    }
    const rejectedI = await adapter.updateInvitation({
      invitationId: ctx.body.invitationId,
      status: "rejected"
    });
    return ctx.json({
      invitation: rejectedI,
      member: null
    });
  }
);
var cancelInvitation = createAuthEndpoint(
  "/organization/cancel-invitation",
  {
    method: "POST",
    body: z13.object({
      invitationId: z13.string()
    }),
    use: [orgMiddleware, orgSessionMiddleware]
  },
  async (ctx) => {
    const session = ctx.context.session;
    const adapter = getOrgAdapter(ctx.context.adapter, ctx.context.orgOptions);
    const invitation = await adapter.findInvitationById(ctx.body.invitationId);
    if (!invitation) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Invitation not found!"
        }
      });
    }
    const member = await adapter.findMemberByOrgId({
      userId: session.user.id,
      organizationId: invitation.organizationId
    });
    if (!member) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "User is not a member of this organization"
        }
      });
    }
    const canCancel = ctx.context.roles[member.role].authorize({
      invitation: ["cancel"]
    });
    if (canCancel.error) {
      return ctx.json(null, {
        status: 403,
        body: {
          message: "You are not allowed to cancel this invitation"
        }
      });
    }
    const canceledI = await adapter.updateInvitation({
      invitationId: ctx.body.invitationId,
      status: "canceled"
    });
    return ctx.json(canceledI);
  }
);
var getInvitation = createAuthEndpoint(
  "/organization/get-invitation",
  {
    method: "GET",
    use: [orgMiddleware],
    requireHeaders: true,
    query: z13.object({
      id: z13.string()
    })
  },
  async (ctx) => {
    const session = await getSessionFromCtx(ctx);
    if (!session) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "User not logged in"
        }
      });
    }
    const adapter = getOrgAdapter(ctx.context.adapter, ctx.context.orgOptions);
    const invitation = await adapter.findInvitationById(ctx.query.id);
    if (!invitation || invitation.status !== "pending" || invitation.expiresAt < /* @__PURE__ */ new Date()) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Invitation not found!"
        }
      });
    }
    if (invitation.email !== session.user.email) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "You are not the recipient of the invitation"
        }
      });
    }
    const organization2 = await adapter.findOrganizationById(
      invitation.organizationId
    );
    if (!organization2) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Organization not found!"
        }
      });
    }
    const member = await adapter.findMemberByOrgId({
      userId: invitation.inviterId,
      organizationId: invitation.organizationId
    });
    if (!member) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Inviter is no longer a member of this organization"
        }
      });
    }
    return ctx.json({
      ...invitation,
      organizationName: organization2.name,
      organizationSlug: organization2.slug,
      inviterEmail: member.email
    });
  }
);

// src/plugins/organization/routes/crud-members.ts
import { z as z14 } from "zod";
var removeMember = createAuthEndpoint(
  "/organization/remove-member",
  {
    method: "POST",
    body: z14.object({
      memberIdOrEmail: z14.string(),
      /**
       * If not provided, the active organization will be used
       */
      organizationId: z14.string().optional()
    }),
    use: [orgMiddleware, orgSessionMiddleware]
  },
  async (ctx) => {
    const session = ctx.context.session;
    const orgId = ctx.body.organizationId || session.session.activeOrganizationId;
    if (!orgId) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "No active organization found!"
        }
      });
    }
    const adapter = getOrgAdapter(ctx.context.adapter, ctx.context.orgOptions);
    const member = await adapter.findMemberByOrgId({
      userId: session.user.id,
      organizationId: orgId
    });
    if (!member) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Member not found!"
        }
      });
    }
    const role2 = ctx.context.roles[member.role];
    if (!role2) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Role not found!"
        }
      });
    }
    const isLeaving = session.user.email === ctx.body.memberIdOrEmail || member.id === ctx.body.memberIdOrEmail;
    const isOwnerLeaving = isLeaving && member.role === (ctx.context.orgOptions?.creatorRole || "owner");
    if (isOwnerLeaving) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "You cannot leave the organization as the owner"
        }
      });
    }
    const canDeleteMember = isLeaving || role2.authorize({
      member: ["delete"]
    }).success;
    if (!canDeleteMember) {
      return ctx.json(null, {
        body: {
          message: "You are not allowed to delete this member"
        },
        status: 403
      });
    }
    let existing = null;
    if (ctx.body.memberIdOrEmail.includes("@")) {
      existing = await adapter.findMemberByEmail({
        email: ctx.body.memberIdOrEmail,
        organizationId: orgId
      });
    } else {
      existing = await adapter.findMemberById(ctx.body.memberIdOrEmail);
    }
    if (existing?.organizationId !== orgId) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Member not found!"
        }
      });
    }
    await adapter.deleteMember(existing.id);
    if (session.user.id === existing.userId && session.session.activeOrganizationId === existing.organizationId) {
      await adapter.setActiveOrganization(session.session.id, null);
    }
    return ctx.json({
      member: existing
    });
  }
);
var updateMemberRole = createAuthEndpoint(
  "/organization/update-member-role",
  {
    method: "POST",
    body: z14.object({
      role: z14.enum(["admin", "member", "owner"]),
      memberId: z14.string(),
      /**
       * If not provided, the active organization will be used
       */
      organizationId: z14.string().optional()
    }),
    use: [orgMiddleware, orgSessionMiddleware]
  },
  async (ctx) => {
    const session = ctx.context.session;
    const orgId = ctx.body.organizationId || session.session.activeOrganizationId;
    if (!orgId) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "No active organization found!"
        }
      });
    }
    const adapter = getOrgAdapter(ctx.context.adapter, ctx.context.orgOptions);
    const member = await adapter.findMemberByOrgId({
      userId: session.user.id,
      organizationId: orgId
    });
    if (!member) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Member not found!"
        }
      });
    }
    const role2 = ctx.context.roles[member.role];
    if (!role2) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Role not found!"
        }
      });
    }
    const canUpdateMember = role2.authorize({
      member: ["update"]
    }).error || ctx.body.role === "owner" && member.role !== "owner";
    if (canUpdateMember) {
      return ctx.json(null, {
        body: {
          message: "You are not allowed to update this member"
        },
        status: 403
      });
    }
    const updatedMember = await adapter.updateMember(
      ctx.body.memberId,
      ctx.body.role
    );
    if (!updatedMember) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Member not found!"
        }
      });
    }
    return ctx.json(updatedMember);
  }
);

// src/plugins/organization/routes/crud-org.ts
import { z as z15 } from "zod";
var createOrganization = createAuthEndpoint(
  "/organization/create",
  {
    method: "POST",
    body: z15.object({
      name: z15.string(),
      slug: z15.string(),
      userId: z15.string().optional(),
      logo: z15.string().optional(),
      metadata: z15.record(z15.string()).optional()
    }),
    use: [orgMiddleware, orgSessionMiddleware]
  },
  async (ctx) => {
    const user = ctx.context.session.user;
    if (!user) {
      return ctx.json(null, {
        status: 401
      });
    }
    const options = ctx.context.orgOptions;
    const canCreateOrg = typeof options?.allowUserToCreateOrganization === "function" ? await options.allowUserToCreateOrganization(user) : options?.allowUserToCreateOrganization === void 0 ? true : options.allowUserToCreateOrganization;
    if (!canCreateOrg) {
      return ctx.json(null, {
        status: 403,
        body: {
          message: "You are not allowed to create organizations"
        }
      });
    }
    const adapter = getOrgAdapter(ctx.context.adapter, options);
    const userOrganizations = await adapter.listOrganizations(user.id);
    const hasReachedOrgLimit = typeof options.organizationLimit === "number" ? userOrganizations.length >= options.organizationLimit : typeof options.organizationLimit === "function" ? await options.organizationLimit(user) : false;
    if (hasReachedOrgLimit) {
      return ctx.json(null, {
        status: 403,
        body: {
          message: "You have reached the maximum number of organizations"
        }
      });
    }
    const existingOrganization = await adapter.findOrganizationBySlug(
      ctx.body.slug
    );
    if (existingOrganization) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Organization with this slug already exists"
        }
      });
    }
    const organization2 = await adapter.createOrganization({
      organization: {
        id: generateId(),
        slug: ctx.body.slug,
        name: ctx.body.name,
        logo: ctx.body.logo,
        createdAt: /* @__PURE__ */ new Date(),
        metadata: ctx.body.metadata
      },
      user
    });
    return ctx.json(organization2);
  }
);
var updateOrganization = createAuthEndpoint(
  "/organization/update",
  {
    method: "POST",
    body: z15.object({
      data: z15.object({
        name: z15.string().optional(),
        slug: z15.string().optional()
      }).partial(),
      orgId: z15.string().optional()
    }),
    requireHeaders: true,
    use: [orgMiddleware]
  },
  async (ctx) => {
    const session = await ctx.context.getSession(ctx);
    if (!session) {
      return ctx.json(null, {
        status: 401
      });
    }
    const orgId = ctx.body.orgId || session.session.activeOrganizationId;
    if (!orgId) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Organization id not found!"
        }
      });
    }
    const adapter = getOrgAdapter(ctx.context.adapter, ctx.context.orgOptions);
    const member = await adapter.findMemberByOrgId({
      userId: session.user.id,
      organizationId: orgId
    });
    if (!member) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "User is not a member of this organization!"
        }
      });
    }
    const role2 = ctx.context.roles[member.role];
    if (!role2) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Role not found!"
        }
      });
    }
    const canUpdateOrg = role2.authorize({
      organization: ["update"]
    });
    if (canUpdateOrg.error) {
      return ctx.json(null, {
        body: {
          message: "You are not allowed to update this organization"
        },
        status: 403
      });
    }
    const updatedOrg = await adapter.updateOrganization(orgId, ctx.body.data);
    return ctx.json(updatedOrg);
  }
);
var deleteOrganization = createAuthEndpoint(
  "/organization/delete",
  {
    method: "POST",
    body: z15.object({
      orgId: z15.string()
    }),
    requireHeaders: true,
    use: [orgMiddleware]
  },
  async (ctx) => {
    const session = await ctx.context.getSession(ctx);
    if (!session) {
      return ctx.json(null, {
        status: 401
      });
    }
    const orgId = ctx.body.orgId;
    if (!orgId) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Organization id not found!"
        }
      });
    }
    const adapter = getOrgAdapter(ctx.context.adapter, ctx.context.orgOptions);
    const member = await adapter.findMemberByOrgId({
      userId: session.user.id,
      organizationId: orgId
    });
    if (!member) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "User is not a member of this organization!"
        }
      });
    }
    const role2 = ctx.context.roles[member.role];
    if (!role2) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Role not found!"
        }
      });
    }
    const canDeleteOrg = role2.authorize({
      organization: ["delete"]
    });
    if (canDeleteOrg.error) {
      return ctx.json(null, {
        body: {
          message: "You are not allowed to delete this organization"
        },
        status: 403
      });
    }
    if (orgId === session.session.activeOrganizationId) {
      await adapter.setActiveOrganization(session.session.id, null);
    }
    await adapter.deleteOrganization(orgId);
    return ctx.json(orgId);
  }
);
var getFullOrganization = createAuthEndpoint(
  "/organization/get-full",
  {
    method: "GET",
    query: z15.object({
      orgId: z15.string().optional()
    }),
    requireHeaders: true,
    use: [orgMiddleware, orgSessionMiddleware]
  },
  async (ctx) => {
    const session = ctx.context.session;
    const orgId = ctx.query.orgId || session.session.activeOrganizationId;
    if (!orgId) {
      return ctx.json(null, {
        status: 400,
        body: {
          message: "Organization id not found!"
        }
      });
    }
    const adapter = getOrgAdapter(ctx.context.adapter, ctx.context.orgOptions);
    const organization2 = await adapter.findFullOrganization(
      orgId,
      ctx.context.db || void 0
    );
    if (!organization2) {
      return ctx.json(null, {
        status: 404,
        body: {
          message: "Organization not found!"
        }
      });
    }
    return ctx.json(organization2);
  }
);
var setActiveOrganization = createAuthEndpoint(
  "/organization/activate",
  {
    method: "POST",
    body: z15.object({
      orgId: z15.string().nullable().optional()
    }),
    use: [orgSessionMiddleware, orgMiddleware]
  },
  async (ctx) => {
    const adapter = getOrgAdapter(ctx.context.adapter, ctx.context.orgOptions);
    const session = ctx.context.session;
    let orgId = ctx.body.orgId;
    if (orgId === null) {
      const sessionOrgId = session.session.activeOrganizationId;
      if (!sessionOrgId) {
        return ctx.json(null);
      }
      await adapter.setActiveOrganization(session.session.id, null);
      return ctx.json(null);
    }
    if (!orgId) {
      const sessionOrgId = session.session.activeOrganizationId;
      if (!sessionOrgId) {
        return ctx.json(null);
      }
      orgId = sessionOrgId;
    }
    const isMember = await adapter.findMemberByOrgId({
      userId: session.user.id,
      organizationId: orgId
    });
    if (!isMember) {
      await adapter.setActiveOrganization(session.session.id, null);
      return ctx.json(null, {
        status: 400,
        body: {
          message: "You are not a member of this organization"
        }
      });
    }
    await adapter.setActiveOrganization(session.session.id, orgId);
    const organization2 = await adapter.findFullOrganization(
      orgId,
      ctx.context.db || void 0
    );
    return ctx.json(organization2);
  }
);
var listOrganization = createAuthEndpoint(
  "/organization/list",
  {
    method: "GET",
    use: [orgMiddleware, orgSessionMiddleware]
  },
  async (ctx) => {
    const adapter = getOrgAdapter(ctx.context.adapter, ctx.context.orgOptions);
    const organizations = await adapter.listOrganizations(
      ctx.context.session.user.id
    );
    return ctx.json(organizations);
  }
);

// src/plugins/organization/organization.ts
var organization = (options) => {
  const endpoints = {
    createOrganization,
    updateOrganization,
    deleteOrganization,
    setActiveOrganization,
    getFullOrganization,
    listOrganization,
    createInvitation,
    cancelInvitation,
    acceptInvitation,
    getInvitation,
    rejectInvitation,
    removeMember,
    updateMemberRole
  };
  const roles = {
    ...defaultRoles,
    ...options?.roles
  };
  const api = shimContext(endpoints, {
    orgOptions: options || {},
    roles,
    getSession: async (context) => {
      return await getSessionFromCtx(context);
    }
  });
  return {
    id: "organization",
    endpoints: {
      ...api,
      hasPermission: createAuthEndpoint(
        "/organization/has-permission",
        {
          method: "POST",
          requireHeaders: true,
          body: z16.object({
            permission: z16.record(z16.string(), z16.array(z16.string()))
          }),
          use: [orgSessionMiddleware]
        },
        async (ctx) => {
          if (!ctx.context.session.session.activeOrganizationId) {
            throw new APIError7("BAD_REQUEST", {
              message: "No active organization"
            });
          }
          const adapter = getOrgAdapter(ctx.context.adapter);
          const member = await adapter.findMemberByOrgId({
            userId: ctx.context.session.user.id,
            organizationId: ctx.context.session.session.activeOrganizationId || ""
          });
          if (!member) {
            throw new APIError7("UNAUTHORIZED", {
              message: "You are not a member of this organization"
            });
          }
          const role2 = roles[member.role];
          const result = role2.authorize(ctx.body.permission);
          if (result.error) {
            return ctx.json(
              {
                error: result.error,
                success: false
              },
              {
                status: 403
              }
            );
          }
          return ctx.json({
            error: null,
            success: true
          });
        }
      )
    },
    schema: {
      session: {
        fields: {
          activeOrganizationId: {
            type: "string",
            required: false
          }
        }
      },
      organization: {
        fields: {
          name: {
            type: "string",
            required: true
          },
          slug: {
            type: "string",
            unique: true
          },
          logo: {
            type: "string",
            required: false
          },
          createdAt: {
            type: "date",
            required: true
          },
          metadata: {
            type: "string",
            required: false
          }
        }
      },
      member: {
        fields: {
          organizationId: {
            type: "string",
            required: true,
            references: {
              model: "organization",
              field: "id"
            }
          },
          userId: {
            type: "string",
            required: true
          },
          email: {
            type: "string",
            required: true
          },
          role: {
            type: "string",
            required: true,
            defaultValue: "member"
          },
          createdAt: {
            type: "date",
            required: true
          }
        }
      },
      invitation: {
        fields: {
          organizationId: {
            type: "string",
            required: true,
            references: {
              model: "organization",
              field: "id"
            }
          },
          email: {
            type: "string",
            required: true
          },
          role: {
            type: "string",
            required: false
          },
          status: {
            type: "string",
            required: true,
            defaultValue: "pending"
          },
          expiresAt: {
            type: "date",
            required: true
          },
          inviterId: {
            type: "string",
            references: {
              model: "user",
              field: "id"
            },
            required: true
          }
        }
      }
    },
    $Infer: {
      Organization: {},
      Invitation: {},
      Member: {},
      ActiveOrganization: {}
    }
  };
};

// src/plugins/two-factor/index.ts
import { z as z21 } from "zod";

// src/plugins/two-factor/backup-codes/index.ts
import { z as z18 } from "zod";

// src/plugins/two-factor/verify-middleware.ts
import { APIError as APIError8 } from "better-call";

// src/plugins/two-factor/constant.ts
var TWO_FACTOR_COOKIE_NAME = "two-factor";
var TRUST_DEVICE_COOKIE_NAME = "trust-device";

// src/plugins/two-factor/verify-middleware.ts
import { z as z17 } from "zod";
var verifyTwoFactorMiddleware = createAuthMiddleware(
  {
    body: z17.object({
      /**
       * if true, the device will be trusted
       * for 30 days. It'll be refreshed on
       * every sign in request within this time.
       */
      trustDevice: z17.boolean().optional(),
      callbackURL: z17.string().optional()
    })
  },
  async (ctx) => {
    const cookieName = ctx.context.createAuthCookie(TWO_FACTOR_COOKIE_NAME);
    const cookie = await ctx.getSignedCookie(
      cookieName.name,
      ctx.context.secret
    );
    if (!cookie) {
      throw new APIError8("UNAUTHORIZED", {
        message: "invalid two factor cookie"
      });
    }
    const [userId, hash] = cookie.split("!");
    if (!userId || !hash) {
      throw new APIError8("UNAUTHORIZED", {
        message: "invalid two factor cookie"
      });
    }
    const sessions = await ctx.context.adapter.findMany({
      model: "session",
      where: [
        {
          field: "userId",
          value: userId
        }
      ]
    });
    if (!sessions.length) {
      throw new APIError8("UNAUTHORIZED", {
        message: "invalid session"
      });
    }
    const activeSessions = sessions.filter(
      (session) => session.expiresAt > /* @__PURE__ */ new Date()
    );
    if (!activeSessions) {
      throw new APIError8("UNAUTHORIZED", {
        message: "invalid session"
      });
    }
    for (const session of activeSessions) {
      const hashToMatch = await hs256(ctx.context.secret, session.id);
      const user = await ctx.context.adapter.findOne({
        model: "user",
        where: [
          {
            field: "id",
            value: session.userId
          }
        ]
      });
      if (!user) {
        throw new APIError8("UNAUTHORIZED", {
          message: "invalid session"
        });
      }
      if (hashToMatch === hash) {
        return {
          valid: async () => {
            await setSessionCookie(ctx, session.id, false);
            if (ctx.body.trustDevice) {
              const trustDeviceCookie = ctx.context.createAuthCookie(
                TRUST_DEVICE_COOKIE_NAME,
                {
                  maxAge: 30 * 24 * 60 * 60
                  // 30 days, it'll be refreshed on sign in requests
                }
              );
              const token = await hs256(
                ctx.context.secret,
                `${user.id}!${session.id}`
              );
              await ctx.setSignedCookie(
                trustDeviceCookie.name,
                `${token}!${session.id}`,
                ctx.context.secret,
                trustDeviceCookie.options
              );
            }
            if (ctx.body.callbackURL) {
              return ctx.json({
                status: true,
                callbackURL: ctx.body.callbackURL,
                redirect: true
              });
            }
            return ctx.json({ status: true });
          },
          invalid: async () => {
            return ctx.json(
              { status: false },
              {
                status: 401,
                body: {
                  message: "Invalid code"
                }
              }
            );
          },
          session: {
            id: session.id,
            userId: session.userId,
            expiresAt: session.expiresAt,
            user
          }
        };
      }
    }
    throw new APIError8("UNAUTHORIZED", {
      message: "invalid two factor authentication"
    });
  }
);

// src/plugins/two-factor/backup-codes/index.ts
function generateBackupCodesFn(options) {
  return Array.from({ length: options?.amount ?? 10 }).fill(null).map(
    () => generateRandomString(options?.length ?? 10, alphabet("a-z", "0-9"))
  ).map((code) => `${code.slice(0, 5)}-${code.slice(5)}`);
}
async function generateBackupCodes(secret, options) {
  const key = secret;
  const backupCodes = options?.customBackupCodesGenerate ? options.customBackupCodesGenerate() : generateBackupCodesFn();
  const encCodes = symmetricEncrypt({
    data: JSON.stringify(backupCodes),
    key
  });
  return {
    backupCodes,
    encryptedBackupCodes: encCodes
  };
}
async function verifyBackupCode(data, key) {
  const codes = await getBackupCodes(data.user, key);
  if (!codes) {
    return false;
  }
  return codes.includes(data.code);
}
async function getBackupCodes(user, key) {
  const secret = Buffer.from(
    await symmetricDecrypt({ key, data: user.twoFactorBackupCodes })
  ).toString("utf-8");
  const data = JSON.parse(secret);
  const result = z18.array(z18.string()).safeParse(data);
  if (result.success) {
    return result.data;
  }
  return null;
}
var backupCode2fa = (options) => {
  return {
    id: "backup_code",
    endpoints: {
      verifyBackupCode: createAuthEndpoint(
        "/two-factor/verify-backup-code",
        {
          method: "POST",
          body: z18.object({
            code: z18.string()
          }),
          use: [verifyTwoFactorMiddleware]
        },
        async (ctx) => {
          const validate = verifyBackupCode(
            {
              user: ctx.context.session.user,
              code: ctx.body.code
            },
            ctx.context.secret
          );
          if (!validate) {
            return ctx.json(
              { status: false },
              {
                status: 401
              }
            );
          }
          return ctx.json({ status: true });
        }
      ),
      generateBackupCodes: createAuthEndpoint(
        "/two-factor/generate-backup-codes",
        {
          method: "POST",
          use: [sessionMiddleware]
        },
        async (ctx) => {
          const backupCodes = await generateBackupCodes(
            ctx.context.secret,
            options
          );
          await ctx.context.adapter.update({
            model: "user",
            update: {
              twoFactorEnabled: true,
              twoFactorBackupCodes: backupCodes.encryptedBackupCodes
            },
            where: [
              {
                field: "id",
                value: ctx.context.session.user.id
              }
            ]
          });
          return ctx.json({
            status: true,
            backupCodes: backupCodes.backupCodes
          });
        }
      ),
      viewBackupCodes: createAuthEndpoint(
        "/view/backup-codes",
        {
          method: "GET",
          use: [sessionMiddleware]
        },
        async (ctx) => {
          const user = ctx.context.session.user;
          const backupCodes = getBackupCodes(user, ctx.context.secret);
          return ctx.json({
            status: true,
            backupCodes
          });
        }
      )
    }
  };
};

// src/plugins/two-factor/otp/index.ts
import { APIError as APIError9 } from "better-call";
import { TOTPController } from "oslo/otp";
import { z as z19 } from "zod";
import { TimeSpan as TimeSpan4 } from "oslo";
var otp2fa = (options) => {
  const opts = {
    period: new TimeSpan4(options?.period || 3, "m")
  };
  const totp = new TOTPController({
    digits: 6,
    period: opts.period
  });
  const send2FaOTP = createAuthEndpoint(
    "/two-factor/send-otp",
    {
      method: "POST",
      use: [verifyTwoFactorMiddleware]
    },
    async (ctx) => {
      if (!options || !options.sendOTP) {
        ctx.context.logger.error(
          "send otp isn't configured. Please configure the send otp function on otp options."
        );
        throw new APIError9("BAD_REQUEST", {
          message: "otp isn't configured"
        });
      }
      const user = ctx.context.session.user;
      const code = await totp.generate(Buffer.from(user.twoFactorSecret));
      await options.sendOTP(user, code);
      return ctx.json({ status: true });
    }
  );
  const verifyOTP = createAuthEndpoint(
    "/two-factor/verify-otp",
    {
      method: "POST",
      body: z19.object({
        code: z19.string()
      }),
      use: [verifyTwoFactorMiddleware]
    },
    async (ctx) => {
      const user = ctx.context.session.user;
      if (!user.twoFactorEnabled) {
        throw new APIError9("BAD_REQUEST", {
          message: "two factor isn't enabled"
        });
      }
      const toCheckOtp = await totp.generate(Buffer.from(user.twoFactorSecret));
      if (toCheckOtp === ctx.body.code) {
        return ctx.context.valid();
      } else {
        return ctx.context.invalid();
      }
    }
  );
  return {
    id: "otp",
    endpoints: {
      send2FaOTP,
      verifyOTP
    }
  };
};

// src/plugins/two-factor/totp/index.ts
import { APIError as APIError10 } from "better-call";
import { TimeSpan as TimeSpan5 } from "oslo";
import { TOTPController as TOTPController2, createTOTPKeyURI } from "oslo/otp";
import { z as z20 } from "zod";
var totp2fa = (options) => {
  const opts = {
    digits: 6,
    period: new TimeSpan5(options?.period || 30, "s")
  };
  const generateTOTP = createAuthEndpoint(
    "/totp/generate",
    {
      method: "POST",
      use: [sessionMiddleware]
    },
    async (ctx) => {
      if (!options) {
        ctx.context.logger.error(
          "totp isn't configured. please pass totp option on two factor plugin to enable totp"
        );
        throw new APIError10("BAD_REQUEST", {
          message: "totp isn't configured"
        });
      }
      const session = ctx.context.session.user;
      const totp = new TOTPController2(opts);
      const code = await totp.generate(Buffer.from(session.twoFactorSecret));
      return { code };
    }
  );
  const getTOTPURI = createAuthEndpoint(
    "/two-factor/get-totp-uri",
    {
      method: "GET",
      use: [sessionMiddleware]
    },
    async (ctx) => {
      if (!options) {
        ctx.context.logger.error(
          "totp isn't configured. please pass totp option on two factor plugin to enable totp"
        );
        throw new APIError10("BAD_REQUEST", {
          message: "totp isn't configured"
        });
      }
      const user = ctx.context.session.user;
      if (!user.twoFactorSecret) {
        throw new APIError10("BAD_REQUEST", {
          message: "totp isn't enabled"
        });
      }
      return {
        totpURI: createTOTPKeyURI(
          options?.issuer || "BetterAuth",
          user.email,
          Buffer.from(user.twoFactorSecret),
          opts
        )
      };
    }
  );
  const verifyTOTP = createAuthEndpoint(
    "/two-factor/verify-totp",
    {
      method: "POST",
      body: z20.object({
        code: z20.string(),
        callbackURL: z20.string().optional()
      }),
      use: [verifyTwoFactorMiddleware]
    },
    async (ctx) => {
      if (!options) {
        ctx.context.logger.error(
          "totp isn't configured. please pass totp option on two factor plugin to enable totp"
        );
        throw new APIError10("BAD_REQUEST", {
          message: "totp isn't configured"
        });
      }
      const totp = new TOTPController2(opts);
      const secret = Buffer.from(
        await symmetricDecrypt({
          key: ctx.context.secret,
          data: ctx.context.session.user.twoFactorSecret
        })
      );
      const status = await totp.verify(ctx.body.code, secret);
      if (!status) {
        return ctx.context.invalid();
      }
      return ctx.context.valid();
    }
  );
  return {
    id: "totp",
    endpoints: {
      generateTOTP,
      viewTOTPURI: getTOTPURI,
      verifyTOTP
    }
  };
};

// src/utils/password.ts
async function validatePassword(ctx, data) {
  const accounts = await ctx.context.internalAdapter.findAccounts(data.userId);
  const credentialAccount = accounts?.find(
    (account) => account.providerId === "credential"
  );
  const currentPassword = credentialAccount?.password;
  if (!credentialAccount || !currentPassword) {
    return false;
  }
  const compare = await ctx.context.password.verify(
    currentPassword,
    data.password
  );
  return compare;
}

// src/plugins/two-factor/client.ts
var twoFactorClient = (options = {
  redirect: true,
  twoFactorPage: "/"
}) => {
  return {
    id: "two-factor",
    $InferServerPlugin: {},
    atomListeners: [
      {
        matcher: (path) => path === "/two-factor/enable" || path === "/two-factor/send-otp" || path === "/two-factor/disable",
        signal: "_sessionSignal"
      }
    ],
    pathMethods: {
      "/two-factor/disable": "POST",
      "/two-factor/enable": "POST",
      "/two-factor/send-otp": "POST"
    },
    fetchPlugins: [
      {
        id: "two-factor",
        name: "two-factor",
        hooks: {
          async onSuccess(context) {
            if (context.data?.twoFactorRedirect) {
              if (options.redirect || options.twoFactorPage) {
                if (typeof window !== "undefined") {
                  window.location.href = options.twoFactorPage;
                }
              }
            }
          }
        }
      }
    ]
  };
};

// src/plugins/two-factor/index.ts
var twoFactor = (options) => {
  const totp = totp2fa({
    issuer: options?.issuer || "better-auth",
    ...options?.totpOptions
  });
  const backupCode = backupCode2fa(options?.backupCodeOptions);
  const otp = otp2fa(options?.otpOptions);
  return {
    id: "two-factor",
    endpoints: {
      ...totp.endpoints,
      ...otp.endpoints,
      ...backupCode.endpoints,
      enableTwoFactor: createAuthEndpoint(
        "/two-factor/enable",
        {
          method: "POST",
          body: z21.object({
            password: z21.string().min(8)
          }),
          use: [sessionMiddleware]
        },
        async (ctx) => {
          const user = ctx.context.session.user;
          const { password } = ctx.body;
          const isPasswordValid = await validatePassword(ctx, {
            password,
            userId: user.id
          });
          if (!isPasswordValid) {
            return ctx.json(
              { status: false },
              {
                status: 400,
                body: {
                  message: "Invalid password"
                }
              }
            );
          }
          const secret = generateRandomString(16, alphabet("a-z", "0-9", "-"));
          const encryptedSecret = symmetricEncrypt({
            key: ctx.context.secret,
            data: secret
          });
          const backupCodes = await generateBackupCodes(
            ctx.context.secret,
            options?.backupCodeOptions
          );
          await ctx.context.adapter.update({
            model: "user",
            update: {
              twoFactorSecret: encryptedSecret,
              twoFactorEnabled: true,
              twoFactorBackupCodes: backupCodes.encryptedBackupCodes
            },
            where: [
              {
                field: "id",
                value: user.id
              }
            ]
          });
          return ctx.json({ status: true });
        }
      ),
      disableTwoFactor: createAuthEndpoint(
        "/two-factor/disable",
        {
          method: "POST",
          body: z21.object({
            password: z21.string().min(8)
          }),
          use: [sessionMiddleware]
        },
        async (ctx) => {
          const user = ctx.context.session.user;
          const { password } = ctx.body;
          const isPasswordValid = await validatePassword(ctx, {
            password,
            userId: user.id
          });
          if (!isPasswordValid) {
            return ctx.json(
              { status: false },
              {
                status: 400,
                body: {
                  message: "Invalid password"
                }
              }
            );
          }
          await ctx.context.adapter.update({
            model: "user",
            update: {
              twoFactorEnabled: false
            },
            where: [
              {
                field: "id",
                value: user.id
              }
            ]
          });
          return ctx.json({ status: true });
        }
      )
    },
    options,
    hooks: {
      after: [
        {
          matcher(context) {
            return context.path === "/sign-in/email" || context.path === "/sign-in/username";
          },
          handler: createAuthMiddleware(async (ctx) => {
            const returned = ctx.context.returned;
            if (returned?.status !== 200) {
              return;
            }
            const response = await returned.clone().json();
            if (!response.user.twoFactorEnabled) {
              return;
            }
            const trustDeviceCookieName = ctx.context.createAuthCookie(
              TRUST_DEVICE_COOKIE_NAME,
              {
                maxAge: 30 * 24 * 60 * 60
                // 30 days
              }
            );
            const trustDeviceCookie = await ctx.getSignedCookie(
              trustDeviceCookieName.name,
              ctx.context.secret
            );
            if (trustDeviceCookie) {
              const [token, sessionId] = trustDeviceCookie.split("!");
              const expectedToken = await hs256(
                ctx.context.secret,
                `${response.user.id}!${sessionId}`
              );
              if (token === expectedToken) {
                const newToken = await hs256(
                  ctx.context.secret,
                  `${response.user.id}!${response.session.id}`
                );
                await ctx.setSignedCookie(
                  trustDeviceCookieName.name,
                  `${newToken}!${response.session.id}`,
                  ctx.context.secret,
                  trustDeviceCookieName.options
                );
                return;
              }
            }
            ctx.setCookie(ctx.context.authCookies.sessionToken.name, "", {
              path: "/",
              sameSite: "lax",
              httpOnly: true,
              secure: false,
              maxAge: 0
            });
            const hash = await hs256(ctx.context.secret, response.session.id);
            const cookieName = ctx.context.createAuthCookie(
              TWO_FACTOR_COOKIE_NAME,
              {
                maxAge: 60 * 60 * 24
                // 24 hours,
              }
            );
            await ctx.setSignedCookie(
              cookieName.name,
              `${response.session.userId}!${hash}`,
              ctx.context.secret,
              cookieName.options
            );
            const res = new Response(
              JSON.stringify({
                twoFactorRedirect: true
              }),
              {
                headers: ctx.responseHeader
              }
            );
            return {
              response: res
            };
          })
        }
      ]
    },
    schema: {
      user: {
        fields: {
          twoFactorEnabled: {
            type: "boolean",
            required: false,
            defaultValue: false
          },
          twoFactorSecret: {
            type: "string",
            required: false,
            returned: false
          },
          twoFactorBackupCodes: {
            type: "string",
            required: false,
            returned: false
          }
        }
      }
    },
    rateLimit: [
      {
        pathMatcher(path) {
          return path.startsWith("/two-factor/");
        },
        window: 10,
        max: 3
      }
    ]
  };
};

// src/plugins/passkey/index.ts
import {
  generateAuthenticationOptions,
  generateRegistrationOptions,
  verifyAuthenticationResponse,
  verifyRegistrationResponse
} from "@simplewebauthn/server";
import { APIError as APIError11 } from "better-call";
import { z as z22 } from "zod";

// src/plugins/passkey/client.ts
import {
  WebAuthnError,
  startAuthentication,
  startRegistration
} from "@simplewebauthn/browser";

// src/client/config.ts
import { createFetch } from "@better-fetch/fetch";
import "nanostores";

// src/client/fetch-plugins.ts
import { betterFetch as betterFetch9 } from "@better-fetch/fetch";

// src/client/session-atom.ts
import { atom as atom2 } from "nanostores";

// src/client/query.ts
import "@better-fetch/fetch";
import { atom, onMount } from "nanostores";
var useAuthQuery = (initializedAtom, path, $fetch, options) => {
  const value = atom({
    data: null,
    error: null,
    isPending: false,
    isRefetching: false
  });
  const fn = () => {
    const opts = typeof options === "function" ? options({
      data: value.get().data,
      error: value.get().error,
      isPending: value.get().isPending
    }) : options;
    return $fetch(path, {
      ...opts,
      onSuccess: async (context) => {
        value.set({
          data: context.data,
          error: null,
          isPending: false,
          isRefetching: false
        });
        await opts?.onSuccess?.(context);
      },
      async onError(context) {
        value.set({
          error: context.error,
          data: null,
          isPending: false,
          isRefetching: false
        });
        await opts?.onError?.(context);
      },
      async onRequest(context) {
        const currentValue = value.get();
        value.set({
          isPending: currentValue.data === null,
          data: currentValue.data,
          error: null,
          isRefetching: true
        });
        await opts?.onRequest?.(context);
      }
    });
  };
  initializedAtom = Array.isArray(initializedAtom) ? initializedAtom : [initializedAtom];
  let isMounted = false;
  for (const initAtom of initializedAtom) {
    initAtom.subscribe(() => {
      if (isMounted) {
        fn();
      } else {
        onMount(value, () => {
          fn();
          isMounted = true;
          return () => {
            value.off();
            initAtom.off();
          };
        });
      }
    });
  }
  return value;
};

// src/plugins/passkey/client.ts
import { atom as atom3 } from "nanostores";
var getPasskeyActions = ($fetch, {
  _listPasskeys
}) => {
  const signInPasskey = async (opts, options) => {
    const response = await $fetch(
      "/passkey/generate-authenticate-options",
      {
        method: "POST",
        body: {
          email: opts?.email,
          callbackURL: opts?.callbackURL
        }
      }
    );
    if (!response.data) {
      return response;
    }
    try {
      const res = await startAuthentication(
        response.data,
        opts?.autoFill || false
      );
      const verified = await $fetch("/passkey/verify-authentication", {
        body: {
          response: res
        },
        ...opts?.fetchOptions,
        ...options
      });
      if (!verified.data) {
        return verified;
      }
    } catch (e) {
      console.log(e);
    }
  };
  const registerPasskey = async (opts, fetchOpts) => {
    const options = await $fetch(
      "/passkey/generate-register-options",
      {
        method: "GET"
      }
    );
    if (!options.data) {
      return options;
    }
    try {
      const res = await startRegistration(options.data);
      const verified = await $fetch("/passkey/verify-registration", {
        ...opts?.fetchOptions,
        ...fetchOpts,
        body: {
          response: res,
          name: opts?.name
        }
      });
      if (!verified.data) {
        return verified;
      }
      _listPasskeys.set(Math.random());
    } catch (e) {
      if (e instanceof WebAuthnError) {
        if (e.code === "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED") {
          return {
            data: null,
            error: {
              message: "previously registered",
              status: 400,
              statusText: "BAD_REQUEST"
            }
          };
        }
        if (e.code === "ERROR_CEREMONY_ABORTED") {
          return {
            data: null,
            error: {
              message: "registration cancelled",
              status: 400,
              statusText: "BAD_REQUEST"
            }
          };
        }
        return {
          data: null,
          error: {
            message: e.message,
            status: 400,
            statusText: "BAD_REQUEST"
          }
        };
      }
      return {
        data: null,
        error: {
          message: e instanceof Error ? e.message : "unknown error",
          status: 500,
          statusText: "INTERNAL_SERVER_ERROR"
        }
      };
    }
  };
  return {
    signIn: {
      /**
       * Sign in with a registered passkey
       */
      passkey: signInPasskey
    },
    passkey: {
      /**
       * Add a passkey to the user account
       */
      addPasskey: registerPasskey
    },
    /**
     * Inferred Internal Types
     */
    $Infer: {}
  };
};
var passkeyClient = () => {
  const _listPasskeys = atom3();
  return {
    id: "passkey",
    $InferServerPlugin: {},
    getActions: ($fetch) => getPasskeyActions($fetch, {
      _listPasskeys
    }),
    getAtoms($fetch) {
      const listPasskeys = useAuthQuery(
        _listPasskeys,
        "/passkey/list-user-passkeys",
        $fetch,
        {
          method: "GET",
          credentials: "include"
        }
      );
      return {
        listPasskeys,
        _listPasskeys
      };
    },
    pathMethods: {
      "/passkey/register": "POST",
      "/passkey/authenticate": "POST"
    },
    atomListeners: [
      {
        matcher(path) {
          return path === "/passkey/verify-registration" || path === "/passkey/delete-passkey";
        },
        signal: "_listPasskeys"
      }
    ]
  };
};

// src/plugins/passkey/index.ts
var passkey = (options) => {
  const baseURL = process.env.BETTER_AUTH_URL;
  const rpID = options?.rpID || baseURL?.replace("http://", "").replace("https://", "").replace(":3000", "") || "localhost";
  if (!rpID) {
    throw new BetterAuthError(
      "passkey rpID not found. Please provide a rpID in the options or set the BETTER_AUTH_URL environment variable."
    );
  }
  const opts = {
    origin: null,
    ...options,
    rpID,
    advanced: {
      webAuthnChallengeCookie: "better-auth-passkey",
      ...options?.advanced
    }
  };
  const expirationTime = new Date(Date.now() + 1e3 * 60 * 5);
  const currentTime = /* @__PURE__ */ new Date();
  const maxAgeInSeconds = Math.floor(
    (expirationTime.getTime() - currentTime.getTime()) / 1e3
  );
  return {
    id: "passkey",
    endpoints: {
      generatePasskeyRegistrationOptions: createAuthEndpoint(
        "/passkey/generate-register-options",
        {
          method: "GET",
          use: [sessionMiddleware],
          metadata: {
            client: false
          }
        },
        async (ctx) => {
          const session = ctx.context.session;
          const userPasskeys = await ctx.context.adapter.findMany({
            model: "passkey",
            where: [
              {
                field: "userId",
                value: session.user.id
              }
            ]
          });
          const userID = new Uint8Array(
            Buffer.from(generateRandomString(32, alphabet("a-z", "0-9")))
          );
          let options2;
          options2 = await generateRegistrationOptions({
            rpName: opts.rpName || ctx.context.appName,
            rpID: opts.rpID,
            userID,
            userName: session.user.email || session.user.id,
            attestationType: "none",
            excludeCredentials: userPasskeys.map((passkey2) => ({
              id: passkey2.id,
              transports: passkey2.transports?.split(
                ","
              )
            })),
            authenticatorSelection: {
              residentKey: "preferred",
              userVerification: "preferred",
              authenticatorAttachment: "platform"
            }
          });
          const id = generateRandomString(32, alphabet("a-z", "0-9"));
          await ctx.setSignedCookie(
            opts.advanced.webAuthnChallengeCookie,
            id,
            ctx.context.secret,
            {
              secure: true,
              httpOnly: true,
              sameSite: "lax",
              maxAge: maxAgeInSeconds
            }
          );
          await ctx.context.internalAdapter.createVerificationValue({
            identifier: id,
            value: JSON.stringify({
              expectedChallenge: options2.challenge,
              userData: {
                id: session.user.id
              }
            }),
            expiresAt: expirationTime
          });
          return ctx.json(options2, {
            status: 200
          });
        }
      ),
      generatePasskeyAuthenticationOptions: createAuthEndpoint(
        "/passkey/generate-authenticate-options",
        {
          method: "POST",
          body: z22.object({
            email: z22.string().optional(),
            callbackURL: z22.string().optional()
          }).optional()
        },
        async (ctx) => {
          const session = await getSessionFromCtx(ctx);
          let userPasskeys = [];
          if (session) {
            userPasskeys = await ctx.context.adapter.findMany({
              model: "passkey",
              where: [
                {
                  field: "userId",
                  value: session.user.id
                }
              ]
            });
          }
          const options2 = await generateAuthenticationOptions({
            rpID: opts.rpID,
            userVerification: "preferred",
            ...userPasskeys.length ? {
              allowCredentials: userPasskeys.map((passkey2) => ({
                id: passkey2.id,
                transports: passkey2.transports?.split(
                  ","
                )
              }))
            } : {}
          });
          const data = {
            expectedChallenge: options2.challenge,
            callbackURL: ctx.body?.callbackURL,
            userData: {
              id: session?.user.id || ""
            }
          };
          const id = generateRandomString(32, alphabet("a-z", "0-9"));
          await ctx.setSignedCookie(
            opts.advanced.webAuthnChallengeCookie,
            id,
            ctx.context.secret,
            {
              secure: true,
              httpOnly: true,
              sameSite: "lax",
              maxAge: maxAgeInSeconds
            }
          );
          await ctx.context.internalAdapter.createVerificationValue({
            identifier: id,
            value: JSON.stringify(data),
            expiresAt: expirationTime
          });
          return ctx.json(options2, {
            status: 200
          });
        }
      ),
      verifyPasskeyRegistration: createAuthEndpoint(
        "/passkey/verify-registration",
        {
          method: "POST",
          body: z22.object({
            response: z22.any(),
            name: z22.string().optional()
          }),
          use: [sessionMiddleware]
        },
        async (ctx) => {
          const origin = options?.origin || ctx.headers?.get("origin") || "";
          if (!origin) {
            return ctx.json(null, {
              status: 400
            });
          }
          const resp = ctx.body.response;
          const challengeId = await ctx.getSignedCookie(
            opts.advanced.webAuthnChallengeCookie,
            ctx.context.secret
          );
          if (!challengeId) {
            return ctx.json(null, {
              status: 400,
              statusText: "No challenge found",
              body: {
                message: "No challenge found"
              }
            });
          }
          const data = await ctx.context.internalAdapter.findVerificationValue(
            challengeId
          );
          if (!data) {
            return ctx.json(null, {
              status: 400
            });
          }
          const { expectedChallenge, userData } = JSON.parse(
            data.value
          );
          if (userData.id !== ctx.context.session.user.id) {
            throw new APIError11("UNAUTHORIZED", {
              message: "You are not authorized to register this passkey"
            });
          }
          try {
            const verification = await verifyRegistrationResponse({
              response: resp,
              expectedChallenge,
              expectedOrigin: origin,
              expectedRPID: options?.rpID
            });
            const { verified, registrationInfo } = verification;
            if (!verified || !registrationInfo) {
              return ctx.json(null, {
                status: 400
              });
            }
            const {
              credentialID,
              credentialPublicKey,
              counter,
              credentialDeviceType,
              credentialBackedUp
            } = registrationInfo;
            const pubKey = Buffer.from(credentialPublicKey).toString("base64");
            const userID = generateRandomString(32, alphabet("a-z", "0-9"));
            const newPasskey = {
              name: ctx.body.name,
              userId: userData.id,
              webauthnUserID: userID,
              id: credentialID,
              publicKey: pubKey,
              counter,
              deviceType: credentialDeviceType,
              transports: resp.response.transports.join(","),
              backedUp: credentialBackedUp,
              createdAt: /* @__PURE__ */ new Date()
            };
            const newPasskeyRes = await ctx.context.adapter.create({
              model: "passkey",
              data: newPasskey
            });
            return ctx.json(newPasskeyRes, {
              status: 200
            });
          } catch (e) {
            console.log(e);
            return ctx.json(null, {
              status: 400,
              body: {
                message: "Registration failed"
              }
            });
          }
        }
      ),
      verifyPasskeyAuthentication: createAuthEndpoint(
        "/passkey/verify-authentication",
        {
          method: "POST",
          body: z22.object({
            response: z22.any()
          })
        },
        async (ctx) => {
          const origin = options?.origin || ctx.headers?.get("origin") || "";
          if (!origin) {
            return ctx.json(null, {
              status: 400
            });
          }
          const resp = ctx.body.response;
          const challengeId = await ctx.getSignedCookie(
            opts.advanced.webAuthnChallengeCookie,
            ctx.context.secret
          );
          if (!challengeId) {
            return ctx.json(null, {
              status: 400
            });
          }
          const data = await ctx.context.internalAdapter.findVerificationValue(
            challengeId
          );
          if (!data) {
            return ctx.json(null, {
              status: 400
            });
          }
          const { expectedChallenge, callbackURL } = JSON.parse(
            data.value
          );
          const passkey2 = await ctx.context.adapter.findOne({
            model: "passkey",
            where: [
              {
                field: "id",
                value: resp.id
              }
            ]
          });
          if (!passkey2) {
            return ctx.json(null, {
              status: 401,
              body: {
                message: "Passkey not found"
              }
            });
          }
          try {
            const verification = await verifyAuthenticationResponse({
              response: resp,
              expectedChallenge,
              expectedOrigin: origin,
              expectedRPID: opts.rpID,
              authenticator: {
                credentialID: passkey2.id,
                credentialPublicKey: new Uint8Array(
                  Buffer.from(passkey2.publicKey, "base64")
                ),
                counter: passkey2.counter,
                transports: passkey2.transports?.split(
                  ","
                )
              }
            });
            const { verified } = verification;
            if (!verified)
              return ctx.json(null, {
                status: 401,
                body: {
                  message: "verification failed"
                }
              });
            await ctx.context.adapter.update({
              model: "passkey",
              where: [
                {
                  field: "id",
                  value: passkey2.id
                }
              ],
              update: {
                counter: verification.authenticationInfo.newCounter
              }
            });
            const s = await ctx.context.internalAdapter.createSession(
              passkey2.userId,
              ctx.request
            );
            if (!s) {
              return ctx.json(null, {
                status: 500,
                body: {
                  message: "Failed to create session"
                }
              });
            }
            await setSessionCookie(ctx, s.id);
            if (callbackURL) {
              return ctx.json({
                url: callbackURL,
                redirect: true,
                session: s
              });
            }
            return ctx.json(
              {
                session: s
              },
              {
                status: 200
              }
            );
          } catch (e) {
            ctx.context.logger.error(e);
            return ctx.json(null, {
              status: 400,
              body: {
                message: "Authentication failed"
              }
            });
          }
        }
      ),
      listPasskeys: createAuthEndpoint(
        "/passkey/list-user-passkeys",
        {
          method: "GET",
          use: [sessionMiddleware]
        },
        async (ctx) => {
          const passkeys = await ctx.context.adapter.findMany({
            model: "passkey",
            where: [{ field: "userId", value: ctx.context.session.user.id }]
          });
          return ctx.json(passkeys, {
            status: 200
          });
        }
      ),
      deletePasskey: createAuthEndpoint(
        "/passkey/delete-passkey",
        {
          method: "POST",
          body: z22.object({
            id: z22.string()
          }),
          use: [sessionMiddleware]
        },
        async (ctx) => {
          await ctx.context.adapter.delete({
            model: "passkey",
            where: [
              {
                field: "id",
                value: ctx.body.id
              }
            ]
          });
          return ctx.json(null, {
            status: 200
          });
        }
      )
    },
    schema: {
      passkey: {
        fields: {
          name: {
            type: "string",
            required: false
          },
          publicKey: {
            type: "string",
            required: true
          },
          userId: {
            type: "string",
            references: {
              model: "user",
              field: "id"
            },
            required: true
          },
          webauthnUserID: {
            type: "string",
            required: true
          },
          counter: {
            type: "number",
            required: true
          },
          deviceType: {
            type: "string",
            required: true
          },
          backedUp: {
            type: "boolean",
            required: true
          },
          transports: {
            type: "string",
            required: false
          },
          createdAt: {
            type: "date",
            defaultValue: /* @__PURE__ */ new Date(),
            required: false
          }
        }
      }
    }
  };
};

// src/plugins/username/index.ts
import { z as z23 } from "zod";
import { APIError as APIError12 } from "better-call";
var username = () => {
  return {
    id: "username",
    endpoints: {
      signInUsername: createAuthEndpoint(
        "/sign-in/username",
        {
          method: "POST",
          body: z23.object({
            username: z23.string(),
            password: z23.string(),
            dontRememberMe: z23.boolean().optional(),
            callbackURL: z23.string().optional()
          })
        },
        async (ctx) => {
          const user = await ctx.context.adapter.findOne({
            model: "user",
            where: [
              {
                field: "username",
                value: ctx.body.username
              }
            ]
          });
          if (!user) {
            await ctx.context.password.hash(ctx.body.password);
            ctx.context.logger.error("User not found", { username });
            throw new APIError12("UNAUTHORIZED", {
              message: "Invalid email or password"
            });
          }
          const account = await ctx.context.adapter.findOne({
            model: "account",
            where: [
              {
                field: "userId",
                value: user.id
              },
              {
                field: "providerId",
                value: "credential"
              }
            ]
          });
          if (!account) {
            throw new APIError12("UNAUTHORIZED", {
              message: "Invalid email or password"
            });
          }
          const currentPassword = account?.password;
          if (!currentPassword) {
            ctx.context.logger.error("Password not found", { username });
            throw new APIError12("UNAUTHORIZED", {
              message: "Unexpected error"
            });
          }
          const validPassword = await ctx.context.password.verify(
            currentPassword,
            ctx.body.password
          );
          if (!validPassword) {
            ctx.context.logger.error("Invalid password");
            throw new APIError12("UNAUTHORIZED", {
              message: "Invalid email or password"
            });
          }
          const session = await ctx.context.internalAdapter.createSession(
            user.id,
            ctx.request
          );
          if (!session) {
            return ctx.json(null, {
              status: 500,
              body: {
                message: "Failed to create session",
                status: 500
              }
            });
          }
          await ctx.setSignedCookie(
            ctx.context.authCookies.sessionToken.name,
            session.id,
            ctx.context.secret,
            ctx.body.dontRememberMe ? {
              ...ctx.context.authCookies.sessionToken.options,
              maxAge: void 0
            } : ctx.context.authCookies.sessionToken.options
          );
          return ctx.json({
            user,
            session,
            redirect: !!ctx.body.callbackURL,
            url: ctx.body.callbackURL
          });
        }
      ),
      signUpUsername: createAuthEndpoint(
        "/sign-up/username",
        {
          method: "POST",
          body: z23.object({
            username: z23.string().min(3).max(20),
            name: z23.string(),
            email: z23.string().email(),
            password: z23.string(),
            image: z23.string().optional(),
            callbackURL: z23.string().optional()
          })
        },
        async (ctx) => {
          const res = await signUpEmail({
            ...ctx,
            //@ts-expect-error
            _flag: void 0
          });
          if (!res) {
            return ctx.json(null, {
              status: 400,
              body: {
                message: "Sign up failed",
                status: 400
              }
            });
          }
          const updated = await ctx.context.internalAdapter.updateUserByEmail(
            res.user.email,
            {
              username: ctx.body.username
            }
          );
          if (ctx.body.callbackURL) {
            return ctx.json(
              {
                user: updated,
                session: res.session
              },
              {
                body: {
                  url: ctx.body.callbackURL,
                  redirect: true,
                  ...res
                }
              }
            );
          }
          return ctx.json({
            user: updated,
            session: res.session
          });
        }
      )
    },
    schema: {
      user: {
        fields: {
          username: {
            type: "string",
            required: false,
            unique: true,
            returned: true
          }
        }
      }
    }
  };
};

// src/plugins/bearer/index.ts
import { serializeSigned } from "better-call";
var bearer = () => {
  return {
    id: "bearer",
    hooks: {
      before: [
        {
          matcher(context) {
            return context.request?.headers.get("authorization")?.startsWith("Bearer ") || false;
          },
          handler: async (ctx) => {
            const token = ctx.request?.headers.get("authorization")?.replace("Bearer ", "");
            if (!token) {
              throw new BetterAuthError("No token found");
            }
            const headers = ctx.headers || new Headers();
            const signedToken = await serializeSigned(
              "",
              token,
              ctx.context.secret
            );
            headers.set(
              "cookie",
              `${ctx.context.authCookies.sessionToken.name}=${signedToken.replace("=", "")}`
            );
          }
        }
      ]
    }
  };
};

// src/plugins/magic-link/index.ts
import { z as z24 } from "zod";
import { APIError as APIError13 } from "better-call";
import { validateJWT as validateJWT3 } from "oslo/jwt";
var magicLink = (options) => {
  return {
    id: "magic-link",
    endpoints: {
      signInMagicLink: createAuthEndpoint(
        "/sign-in/magic-link",
        {
          method: "POST",
          requireHeaders: true,
          body: z24.object({
            email: z24.string().email(),
            callbackURL: z24.string().optional(),
            currentURL: z24.string().optional()
          })
        },
        async (ctx) => {
          const { email } = ctx.body;
          const user = await ctx.context.internalAdapter.findUserByEmail(email);
          if (!user) {
            throw new APIError13("UNAUTHORIZED", {
              message: "User not found"
            });
          }
          const token = await createEmailVerificationToken(
            ctx.context.secret,
            email
          );
          const url = `${ctx.context.baseURL}/magic-link/verify?token=${token}&callbackURL=${ctx.body.callbackURL || ctx.body.currentURL}`;
          try {
            await options.sendMagicLink({
              email,
              url,
              token
            });
          } catch (e) {
            ctx.context.logger.error("Failed to send magic link", e);
            throw new APIError13("INTERNAL_SERVER_ERROR", {
              message: "Failed to send magic link"
            });
          }
          return ctx.json({
            status: true
          });
        }
      ),
      magicLinkVerify: createAuthEndpoint(
        "/magic-link/verify",
        {
          method: "GET",
          query: z24.object({
            token: z24.string(),
            callbackURL: z24.string().optional()
          }),
          requireHeaders: true
        },
        async (ctx) => {
          const { token, callbackURL } = ctx.query;
          let jwt;
          try {
            jwt = await validateJWT3(
              "HS256",
              Buffer.from(ctx.context.secret),
              token
            );
          } catch (e) {
            ctx.context.logger.error("Failed to verify email", e);
            if (callbackURL) {
              throw ctx.redirect(`${callbackURL}?error=INVALID_TOKEN`);
            }
            return ctx.json(null, {
              status: 400,
              statusText: "INVALID_TOKEN",
              body: {
                message: "Invalid token"
              }
            });
          }
          const schema = z24.object({
            email: z24.string().email()
          });
          const parsed = schema.parse(jwt.payload);
          const user = await ctx.context.internalAdapter.findUserByEmail(
            parsed.email
          );
          if (!user) {
            if (callbackURL) {
              throw ctx.redirect(`${callbackURL}?error=USER_NOT_FOUND`);
            }
            return ctx.json(null, {
              status: 400,
              statusText: "USER_NOT_FOUND",
              body: {
                message: "User not found"
              }
            });
          }
          const session = await ctx.context.internalAdapter.createSession(
            user.user.id,
            ctx.headers
          );
          if (!session) {
            if (callbackURL) {
              throw ctx.redirect(`${callbackURL}?error=SESSION_NOT_CREATED`);
            }
            return ctx.json(null, {
              status: 400,
              statusText: "SESSION NOT CREATED",
              body: {
                message: "Failed to create session"
              }
            });
          }
          await setSessionCookie(ctx, session.id);
          if (!callbackURL) {
            return ctx.json({
              status: true
            });
          }
          throw ctx.redirect(callbackURL);
        }
      )
    }
  };
};

// src/plugins/phone-number/index.ts
import { z as z25 } from "zod";
import { APIError as APIError14 } from "better-call";
function generateOTP(size) {
  return generateRandomString(size, alphabet("0-9"));
}
var phoneNumber = (options) => {
  const opts = {
    phoneNumber: "phoneNumber",
    phoneNumberVerified: "phoneNumberVerified",
    otp: {
      code: "code",
      phoneNumber: "phoneNumber",
      createdAt: "createdAt",
      expiresIn: options?.otp?.expiresIn || 300
    }
  };
  return {
    id: "phone-number",
    endpoints: {
      signInPhoneNumber: createAuthEndpoint(
        "/sign-in/phone-number",
        {
          method: "POST",
          body: z25.object({
            phoneNumber: z25.string(),
            password: z25.string(),
            dontRememberMe: z25.boolean().optional(),
            callbackURL: z25.string().optional()
          })
        },
        async (ctx) => {
          const user = await ctx.context.adapter.findOne({
            model: "user",
            where: [
              {
                field: opts.phoneNumber,
                value: ctx.body.phoneNumber
              }
            ]
          });
          if (!user) {
            await ctx.context.password.hash(ctx.body.password);
            throw new APIError14("UNAUTHORIZED", {
              message: "Invalid email or password"
            });
          }
          const account = await ctx.context.adapter.findOne({
            model: ctx.context.tables.account.tableName,
            where: [
              {
                field: "userId",
                value: user.id
              },
              {
                field: "providerId",
                value: "credential"
              }
            ]
          });
          if (!account) {
            throw new APIError14("UNAUTHORIZED", {
              message: "Invalid email or password"
            });
          }
          const currentPassword = account?.password;
          if (!currentPassword) {
            ctx.context.logger.warn(
              "Unexpectedly password is missing for the user",
              user
            );
            throw new APIError14("UNAUTHORIZED", {
              message: "Unexpected error"
            });
          }
          const validPassword = await ctx.context.password.verify(
            currentPassword,
            ctx.body.password
          );
          if (!validPassword) {
            ctx.context.logger.error("Invalid password");
            throw new APIError14("UNAUTHORIZED", {
              message: "Invalid email or password"
            });
          }
          const session = await ctx.context.internalAdapter.createSession(
            user.id,
            ctx.request
          );
          if (!session) {
            return ctx.json(null, {
              status: 500,
              body: {
                message: "Failed to create session",
                status: 500
              }
            });
          }
          await ctx.setSignedCookie(
            ctx.context.authCookies.sessionToken.name,
            session.id,
            ctx.context.secret,
            ctx.body.dontRememberMe ? {
              ...ctx.context.authCookies.sessionToken.options,
              maxAge: void 0
            } : ctx.context.authCookies.sessionToken.options
          );
          return ctx.json({
            user,
            session,
            redirect: !!ctx.body.callbackURL,
            url: ctx.body.callbackURL
          });
        }
      ),
      signUpPhoneNumber: createAuthEndpoint(
        "/sign-up/phone-number",
        {
          method: "POST",
          body: z25.object({
            phoneNumber: z25.string().min(3).max(20),
            name: z25.string(),
            email: z25.string().email(),
            password: z25.string(),
            image: z25.string().optional(),
            callbackURL: z25.string().optional()
          })
        },
        async (ctx) => {
          const res = await signUpEmail({
            ...ctx,
            //@ts-expect-error
            _flag: void 0
          });
          if (!res) {
            return ctx.json(null, {
              status: 400,
              body: {
                message: "Sign up failed",
                status: 400
              }
            });
          }
          if (options?.otp?.sendOTPonSignUp) {
            if (!options.otp.sendOTP) {
              logger.warn("sendOTP not implemented");
              throw new APIError14("NOT_IMPLEMENTED", {
                message: "sendOTP not implemented"
              });
            }
            const code = generateOTP(options?.otp?.otpLength || 6);
            await ctx.context.internalAdapter.createVerificationValue({
              value: code,
              identifier: ctx.body.phoneNumber,
              expiresAt: getDate(opts.otp.expiresIn, "sec")
            });
            await options.otp.sendOTP(ctx.body.phoneNumber, code);
          }
          const updated = await ctx.context.internalAdapter.updateUserByEmail(
            res.user.email,
            {
              [opts.phoneNumber]: ctx.body.phoneNumber
            }
          );
          if (ctx.body.callbackURL) {
            return ctx.json(
              {
                user: updated,
                session: res.session
              },
              {
                body: {
                  url: ctx.body.callbackURL,
                  redirect: true,
                  ...res
                }
              }
            );
          }
          return ctx.json({
            user: updated,
            session: res.session
          });
        }
      ),
      sendVerificationCode: createAuthEndpoint(
        "/phone-number/send-verification-code",
        {
          method: "POST",
          body: z25.object({
            phoneNumber: z25.string()
          })
        },
        async (ctx) => {
          if (!options?.otp?.sendOTP) {
            logger.warn("sendOTP not implemented");
            throw new APIError14("NOT_IMPLEMENTED", {
              message: "sendOTP not implemented"
            });
          }
          const code = generateOTP(options?.otp?.otpLength || 6);
          await ctx.context.internalAdapter.createVerificationValue({
            value: code,
            identifier: ctx.body.phoneNumber,
            expiresAt: getDate(opts.otp.expiresIn, "sec")
          });
          await options.otp.sendOTP(ctx.body.phoneNumber, code);
          return ctx.json(
            { code },
            {
              body: {
                message: "Code sent"
              }
            }
          );
        }
      ),
      verifyPhoneNumber: createAuthEndpoint(
        "/phone-number/verify",
        {
          method: "POST",
          body: z25.object({
            phoneNumber: z25.string(),
            code: z25.string()
          })
        },
        async (ctx) => {
          const otp = await ctx.context.internalAdapter.findVerificationValue(
            ctx.body.phoneNumber
          );
          if (!otp || otp.expiresAt < /* @__PURE__ */ new Date()) {
            if (otp && otp.expiresAt < /* @__PURE__ */ new Date()) {
              await ctx.context.internalAdapter.deleteVerificationValue(otp.id);
            }
            return ctx.json(
              {
                status: false
              },
              {
                body: {
                  message: "Invalid code"
                },
                status: 400
              }
            );
          }
          if (otp.value !== ctx.body.code) {
            return ctx.json(
              {
                status: false
              },
              {
                body: {
                  message: "Invalid code"
                },
                status: 400
              }
            );
          }
          await ctx.context.internalAdapter.deleteVerificationValue(otp.id);
          const user = await ctx.context.adapter.findOne({
            model: ctx.context.tables.user.tableName,
            where: [
              {
                value: ctx.body.phoneNumber,
                field: opts.phoneNumber
              }
            ]
          });
          if (!user) {
            throw new APIError14("NOT_FOUND", {
              message: "User with phone number not found"
            });
          }
          await ctx.context.internalAdapter.updateUser(user.id, {
            [opts.phoneNumberVerified]: true
          });
          if (options?.enableAutoSignIn) {
            const session = await getSessionFromCtx(ctx);
            if (!session) {
              const session2 = await ctx.context.internalAdapter.createSession(
                user.id,
                ctx.request
              );
              if (!session2) {
                return ctx.json(null, {
                  status: 500,
                  body: {
                    message: "Failed to create session",
                    status: 500
                  }
                });
              }
              await setSessionCookie(ctx, session2.id);
              return ctx.json({
                user,
                session: session2
              });
            }
          }
          return ctx.json({
            status: true
          });
        }
      ),
      updatePhoneNumber: createAuthEndpoint(
        "/phone-number/update",
        {
          method: "POST",
          body: z25.object({
            phoneNumber: z25.string()
          }),
          use: [sessionMiddleware]
        },
        async (ctx) => {
          if (options?.otp?.sendOTPonUpdate) {
            if (!options.otp.sendOTP) {
              logger.warn("sendOTP not implemented");
              throw new APIError14("NOT_IMPLEMENTED", {
                message: "sendOTP not implemented"
              });
            }
            const code = generateOTP(options?.otp?.otpLength || 6);
            await ctx.context.adapter.create({
              model: ctx.context.tables.verification.tableName,
              data: {
                code,
                phoneNumber: ctx.body.phoneNumber,
                createdAt: getDate(opts.otp.expiresIn, "sec")
              }
            });
            await options.otp.sendOTP(ctx.body.phoneNumber, code);
          }
          const user = await ctx.context.internalAdapter.updateUser(
            ctx.context.session.user.id,
            {
              [opts.phoneNumber]: ctx.body.phoneNumber,
              [opts.phoneNumberVerified]: false
            }
          );
          return ctx.json({
            user
          });
        }
      )
    },
    schema: {
      user: {
        fields: {
          phoneNumber: {
            type: "string",
            required: false,
            unique: true,
            returned: true
          },
          phoneNumberVerified: {
            type: "boolean",
            required: false,
            returned: true
          }
        }
      }
    }
  };
};
export {
  HIDE_METADATA,
  access_exports as ac,
  bearer,
  createAuthEndpoint,
  createAuthMiddleware,
  getPasskeyActions,
  magicLink,
  optionsMiddleware,
  organization,
  passkey,
  passkeyClient,
  phoneNumber,
  twoFactor,
  twoFactorClient,
  username
};
